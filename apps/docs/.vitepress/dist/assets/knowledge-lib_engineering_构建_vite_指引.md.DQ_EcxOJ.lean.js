import{a2 as s,t as a,ao as l,q as e}from"./chunks/framework.tQiMsDJj.js";const t="/assets/vite.OjQ4Kzq7.png",n="/assets/webpack.BnxyK4Yr.png",p="/assets/vite-esm.CS3rKl9R.png",g=JSON.parse('{"title":"Vite","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge-lib/engineering/构建/vite/指引.md","filePath":"knowledge-lib/engineering/构建/vite/指引.md"}'),h={name:"knowledge-lib/engineering/构建/vite/指引.md"};function k(r,i,o,d,u,c){return e(),a("div",null,i[0]||(i[0]=[l('<h1 id="vite" tabindex="-1"><a href="https://vitejs.cn/vite3-cn/guide/" target="_blank" rel="noreferrer">Vite</a> <a class="header-anchor" href="#vite" aria-label="Permalink to &quot;[Vite](https://vitejs.cn/vite3-cn/guide/)&quot;">​</a></h1><p><img src="'+t+'" alt=""></p><p>vite主要由两部分组成：</p><ul><li><p>一个开发服务器。基于 原生 ES 模块 提供了 丰富的内建功能，如速度快到惊人的 模块热更新（HMR）</p></li><li><p>一套构建指令。使用 Rollup 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源</p></li><li><p>开发环节</p><ol><li>首先，当启动vite开发服务器时，vite会检测入口文件</li><li>当你在浏览器中访问程序时，vite将拦截对入口文件及被模块导入的文件的请求</li><li>vite利用浏览器内置的es模块系统来加载模块，这是浏览器原生支持的一种模块加载方式，这与传统的基于打包的构建工具（如webpack）有所不同</li><li>vite会运行一个开发服务器，通过代理的形式将模块请求重定向到实际的模块文件路径，不需要webpack一样先打包，再加载</li><li>当代码有修改时，vite会根据代码的依赖关系对只有发生变化的模块进行重新构建，并将变化传递给浏览器，实现热更新</li></ol></li><li><p>生产环节：</p><ol><li>vite会使用预编译的方式来构建应用程序</li><li>根据入口文件和依赖关系，分析模块的导入关系</li><li>vite会为每个模块都生成单独的、按需加载的优化过的es模块，这样每个模块都可以单独缓存加载</li><li>还会生成用于生产环境的最终打包文件，将所有的模块和资源文件合并并压缩</li></ol></li></ul><blockquote><p>webpack和vite的对比</p></blockquote><ol><li>webpack的痛点</li></ol><ul><li>在构建大型项目的时候，非常的慢</li><li>因为在启动 webpack 项目的时候，webpack 会先对项目进行打包，然后运行的是打包后的文件 <img src="'+n+'" alt=""></li></ul><ol start="2"><li>vite的思路</li></ol><ul><li>不打包，利用浏览器的 import 机制，按需获取内容</li><li>针对 .vue 这样的模块文件，需要做预编译，编译为 JS 文件再返回给浏览器</li><li>Vite 中热更新的实现，底层实际上使用的是 websocket 来实现的 <img src="'+p+`" alt=""></li></ul><h2 id="功能" tabindex="-1">功能 <a class="header-anchor" href="#功能" aria-label="Permalink to &quot;功能&quot;">​</a></h2><ul><li><p>NPM 依赖解析和预构建。原生 ES 导入不支持下面这样的裸模块导入：<code>import { someMethod } from &#39;my-dep&#39;</code>， Vite 将会检测到所有被加载的源文件中的此类裸模块导入，并执行以下操作:</p><ul><li>预构建 它们可以提高页面加载速度，并将 CommonJS / UMD 转换为 ESM 格式。预构建这一步由 esbuild 执行，这使得 Vite 的冷启动时间比任何基于 JavaScript 的打包器都要快得多。</li><li>重写导入为合法的 URL，例如 /node_modules/.vite/deps/my-dep.js?v=f3sf2ebd 以便浏览器能够正确导入它们。 依赖是强缓存的, Vite 通过 HTTP 头来缓存请求得到的依赖</li></ul></li><li><p>模块热替换: Vite 提供了一套原生 ESM 的 HMR API。 具有 HMR 功能的框架可以利用该 API 提供即时、准确的更新，而无需重新加载页面或清除应用程序状态。</p></li><li><p>ts支持：</p><ul><li>Vite 使用 esbuild 将 TypeScript 转译到 JavaScript</li><li>仅执行 .ts 文件的转译工作，并 不 执行任何类型检查（你可以在构建脚本中运行 tsc --noEmit 或者安装 vue-tsc 然后运行 vue-tsc --noEmit 来对你的 *.vue 文件做类型检查）</li></ul></li><li><p>Vue</p><ul><li>jsx:JSX 的转译同样是通过 esbuild,官方提供的 @vitejs/plugin-vue-jsx 插件</li></ul></li><li><p>CSS</p><ul><li>@import内联和变基</li><li>PostCSS</li><li>CSS Module</li><li>CSS 预处理器</li></ul></li><li><p>静态资源处理</p><ul><li>禁用 CSS 注入页面</li><li>JSON</li><li>Glob 导入:支持使用特殊的 import.meta.glob 函数从文件系统导入多个模块</li><li>动态导入</li><li>WebAssembly: 预编译的 .wasm 文件可以通过 ?init 来导入。默认导出一个初始化函数，返回值为所导出 wasm 实例对象的 Promise</li><li>Web Worker <ul><li>一个 Web Worker 可以使用 new Worker() 和 new SharedWorker() 导入</li><li>你可以在导入请求上添加 ?worker 或 ?sharedworker 查询参数来直接导入一个 web worker 脚本</li></ul></li></ul></li><li><p>构建优化</p><ul><li>CSS 代码分割</li><li>预加载指令生成</li><li>异步 Chunk 加载优化</li></ul></li></ul><h2 id="依赖预构建-pre-bundling-dependencies" tabindex="-1">依赖预构建（Pre-bundling dependencies） <a class="header-anchor" href="#依赖预构建-pre-bundling-dependencies" aria-label="Permalink to &quot;依赖预构建（Pre-bundling dependencies）&quot;">​</a></h2><blockquote><p>在你首次使用 Vite 启动项目的时候，会把你的项目依赖预先构建一次</p></blockquote><blockquote><p>依赖预构建仅会在开发模式下应用，并会使用 esbuild 将依赖转为 ESM 模块。在生产构建中则会使用 @rollup/plugin-commonjs</p></blockquote><blockquote><p>将只会在你的依赖或配置发生变化时执行</p></blockquote><p>思考🤔：前面不是说 Vite 相比 Webpack 的优点不就是不打包么？这里预构建又是怎么一回事儿？</p><h3 id="原因" tabindex="-1">原因 <a class="header-anchor" href="#原因" aria-label="Permalink to &quot;原因&quot;">​</a></h3><p>存在的问题：</p><ul><li>某些依赖仍然是以 CommonJS 格式发布的，它们并不兼容原生 ESM 环境</li><li>依赖文件过多，导致请求过多</li></ul><p><strong>1. CommonJS / UMD 兼容性 转换为 ESM 格式。</strong></p><p><strong>2. Vite 将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。</strong></p><blockquote><p>例如，lodash-es 有超过 600 个内置模块！当我们执行 import { debounce } from &#39;lodash-es&#39; 时，浏览器同时发出 600 多个 HTTP 请求！尽管服务器在处理这些请求时没有问题，但大量的请求会在浏览器端造成网络拥塞，导致页面的加载速度相当慢。通过预构建 lodash-es 成为一个模块，我们就只需要一个 HTTP 请求了！</p></blockquote><p>预构建阶段所使用的打包工具是 esbuild，这是一个用 Go 语言编写的构建工具，效率极高，大部分工作都是并行处理的，esbuild 能够迅速将依赖转换为有效的 ES 模块格式，并进行打包，从而优化依赖管理和加载效率。esbuild 所做的事情：</p><ul><li>转换：将一些 CommonJS、UMD 格式的模块转换为 ES 模块格式。</li><li>打包：针对依赖进行打包，减少浏览器在开发环境请求的次数。</li><li>最小化和压缩：这个是在构建阶段，针对代码的最小化和压缩也是 esbuild 来做的。</li></ul><p><strong>3. 缓存</strong></p><ul><li>文件系统缓存：Vite 会将预构建的依赖缓存到 node_modules/.vite。它根据几个源来决定是否需要重新运行预构建步骤: <ul><li>package.json 的依赖项发生变化</li><li>包管理器的lockfile发生变化</li><li>vite.config.js 相关字段发生变化</li><li>如果出于某些原因，你想要强制 Vite 重新构建依赖，你可以用 --force 命令行选项启动开发服务器，或者手动删除 node_modules/.vite 目录</li></ul></li><li>浏览器缓存： <ul><li>解析后的依赖请求会以 HTTP 头 max-age=31536000,immutable 强缓存，以提高在开发时的页面重载性能。</li><li>调试： <ul><li>NetWork: disableCache: true</li><li>重启server --force</li><li>重新载入页面</li></ul></li></ul></li></ul><h3 id="自定义行为" tabindex="-1">自定义行为 <a class="header-anchor" href="#自定义行为" aria-label="Permalink to &quot;自定义行为&quot;">​</a></h3><p>默认的依赖项发现为启发式可能并不总是可取的。在你想要显式地从列表中包含/排除依赖项的情况下, 请使用 <code>optimizeDeps</code> 配置项。</p><p>当你遇到不能直接在源码中发现的 import 时，optimizeDeps.include 或 optimizeDeps.exclude 就是典型的用例。</p><h2 id="构建" tabindex="-1">构建 <a class="header-anchor" href="#构建" aria-label="Permalink to &quot;构建&quot;">​</a></h2><blockquote><p>不同于 依赖预构建 用到的 esbuild，生产构建使用的工具是 rollup. 因为 rollup 提供了一些特性和优势，特别适合用于生产环境的代码打包和优化</p></blockquote><h2 id="静态资源处理" tabindex="-1">静态资源处理 <a class="header-anchor" href="#静态资源处理" aria-label="Permalink to &quot;静态资源处理&quot;">​</a></h2><h3 id="将资源引入为url" tabindex="-1">将资源引入为URL <a class="header-anchor" href="#将资源引入为url" aria-label="Permalink to &quot;将资源引入为URL&quot;">​</a></h3><p>引入一个静态资源会返回解析后的公共路径：例如，imgUrl 在开发时会是 /img.png，在生产构建后会是 /assets/img.2d8efhg.png。</p><p>行为类似于 Webpack 的 file-loader。区别在于导入既可以使用绝对公共路径（基于开发期间的项目根路径），也可以使用相对路径。</p><ul><li>url() 在 CSS 中的引用也以同样的方式处理</li><li>如果 Vite 使用了 Vue 插件，Vue SFC 模板中的资源引用都将自动转换为导入</li><li>常见的图像、媒体和字体文件类型被自动检测为资源。你可以使用 <code>assetsInclude</code> 选项 扩展内部列表。</li><li>引用的资源作为构建资源图的一部分包括在内，将生成散列文件名，并可以由插件进行处理以进行优化</li><li>较小的资源体积小于 <code>assetsInlineLimit</code> 选项值 则会被内联为 base64 data URL，以减少 HTTP 请求</li><li>显示URL引入：未被包含在内部列表或 assetsInclude 中的资源，可以使用 <code>?url</code> 后缀显式导入为一个 URL</li><li>将资源引入为字符串：资源可以使用 <code>?raw</code> 后缀声明作为字符串引入</li><li>导入脚本作为 Worker: 脚本可以通过 <code>?worker</code> 或 <code>?sharedworker</code> 后缀导入为 web worker。</li><li>public: 目录默认是 <code>&lt;root&gt;/public</code>，但可以通过 publicDir 选项 来配置 <ul><li>打包时会被完整复制到目标目录的根目录下</li><li>public 中的资源不应该被 JavaScript 文件引用</li></ul></li></ul><h3 id="new-url-url-import-meta-url" tabindex="-1">new URL(url, import.meta.url) <a class="header-anchor" href="#new-url-url-import-meta-url" aria-label="Permalink to &quot;new URL(url, import.meta.url)&quot;">​</a></h3><p>import.meta.url 是一个 ESM 的原生功能，会暴露当前模块的 URL。</p><p>将它与原生的 URL 构造器 组合使用，在一个 JavaScript 模块中，通过相对路径我们就能得到一个被完整解析的静态资源 URL：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> imgUrl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> URL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./img.png&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">meta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.url).href</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hero-img&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).src </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> imgUrl</span></span></code></pre></div><ul><li>在现代浏览器中能够原生使用 - 实际上，Vite 并不需要在开发阶段处理这些代码</li><li>在生产构建时，Vite 才会进行必要的转换保证 URL 在打包和资源哈希后仍指向正确的地址</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这个 URL 字符串必须是静态的, Vite 不会转换这个</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> imgUrl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> URL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(imagePath, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">meta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.url).href</span></span></code></pre></div><ul><li>无法在 SSR 中使用, 因为 import.meta.url 在浏览器和 Node.js 中有不同的语义</li></ul><h3 id="打包后的图片路径-vite自动依赖分析" tabindex="-1">打包后的图片路径(vite自动依赖分析) <a class="header-anchor" href="#打包后的图片路径-vite自动依赖分析" aria-label="Permalink to &quot;打包后的图片路径(vite自动依赖分析)&quot;">​</a></h3><ul><li>css静态链接路径</li><li>标签静态资源链接路径</li><li>import()中的带有变量的路径 <ul><li>如<code>import(\`./assets/\${val}.jpg\`)</code>，vite会将./assets/下所有jpg文件打包成一个js内引用jpg</li><li>因此import不能是全部变量<code>import(\${val})</code>，这样什么都分析不出来</li></ul></li><li>URL构造器：不会生成js，更简洁, <code>new URL(&#39;/path/\${var}&#39;, import.meta.url)</code></li></ul><h2 id="构建生产版本" tabindex="-1">构建生产版本 <a class="header-anchor" href="#构建生产版本" aria-label="Permalink to &quot;构建生产版本&quot;">​</a></h2><p>当需要将应用部署到生产环境时，只需运行 vite build 命令。</p><p>默认情况下，它使用 <code>&lt;root&gt;/index.html</code> 作为其构建入口点，并生成能够静态部署的应用程序包。</p><h3 id="浏览器兼容性" tabindex="-1">浏览器兼容性 <a class="header-anchor" href="#浏览器兼容性" aria-label="Permalink to &quot;浏览器兼容性&quot;">​</a></h3><p>默认情况下，Vite 的目标是能够 支持原生 ESM script 标签、支持原生 ESM 动态导入 和 import.meta 的浏览器：</p><ul><li>Chrome &gt;=87</li><li>Firefox &gt;=78</li><li>Safari &gt;=13</li><li>Edge &gt;=88</li></ul><p>build.target 配置项 指定构建目标，最低支持 es2015</p><p>默认情况下 Vite 只处理语法转译，且 默认不包含任何 polyfill</p><p>传统浏览器可以通过插件 <code>@vitejs/plugin-legacy</code> 来支持，它将自动生成传统版本的 chunk 及与其相对应 ES 语言特性方面的 polyfill。兼容版的 chunk 只会在不支持原生 ESM 的浏览器中进行<code>按需加载</code>。</p><h3 id="公共基础路径" tabindex="-1">公共基础路径 <a class="header-anchor" href="#公共基础路径" aria-label="Permalink to &quot;公共基础路径&quot;">​</a></h3><p>如果你需要在嵌套的公共路径下部署项目，只需指定 base 配置项，然后所有资源的路径都将据此配置重写</p><p>由 JS 引入的资源 URL，CSS 中的 url() 引用以及 .html 文件中引用的资源在构建过程中都会自动调整，以适配此选项</p><p>当访问过程中需要使用动态连接的 url 时，可以使用全局注入的 import.meta.env.BASE_URL 变量，它的值为公共基础路径</p><h3 id="自定义构建" tabindex="-1">自定义构建 <a class="header-anchor" href="#自定义构建" aria-label="Permalink to &quot;自定义构建&quot;">​</a></h3><p>build.rollupOptions 直接调整底层的 Rollup 选项：</p><h3 id="产物分块策略" tabindex="-1">产物分块策略 <a class="header-anchor" href="#产物分块策略" aria-label="Permalink to &quot;产物分块策略&quot;">​</a></h3><p>配置在使用 build.rollupOptions.output.manualChunks 时各个 chunk 是如何分割的</p><p>到 Vite 2.8 时，默认的策略是将 chunk 分割为 index 和 vendor。这对一些 SPA 来说是好的策略，但是要对每一种用例目标都提供一种通用解决方案是非常困难的。</p><p>从 Vite 2.9 起，manualChunks 默认情况下不再被更改。你可以通过在配置文件中添加 splitVendorChunkPlugin 来继续使用 “分割 Vendor Chunk” 策略</p><h3 id="文件变化时重新构建" tabindex="-1">文件变化时重新构建 <a class="header-anchor" href="#文件变化时重新构建" aria-label="Permalink to &quot;文件变化时重新构建&quot;">​</a></h3><p>你可以使用 vite build --watch 来启用 rollup 的监听器。或者，你可以直接通过 build.watch 调整底层的 WatcherOptions 选项：</p><h3 id="多页面应用模式" tabindex="-1">多页面应用模式 <a class="header-anchor" href="#多页面应用模式" aria-label="Permalink to &quot;多页面应用模式&quot;">​</a></h3><p>在构建过程中，你只需指定多个 .html 文件作为入口点即可</p><h3 id="库模式" tabindex="-1">库模式 <a class="header-anchor" href="#库模式" aria-label="Permalink to &quot;库模式&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// vite.config.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { resolve } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;path&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { defineConfig } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vite&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  build: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    lib: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      entry: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__dirname, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;lib/main.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;MyLib&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // the proper extensions will be added</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      fileName: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;my-lib&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rollupOptions: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 确保外部化处理那些你不想打包进库的依赖</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      external: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      output: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 在 UMD 构建模式下为这些外部化的依赖提供一个全局变量</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        globals: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          vue: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Vue&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>推荐在你库的 package.json 中使用如下格式：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;my-lib&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;type&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;module&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;files&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dist&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;main&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./dist/my-lib.umd.cjs&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;module&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./dist/my-lib.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;exports&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;import&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./dist/my-lib.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;require&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./dist/my-lib.umd.cjs&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>如果 package.json 不包含 &quot;type&quot;: &quot;module&quot;，Vite 会生成不同的文件后缀名以兼容 Node.js。.js 会变为 .mjs 而 .cjs 会变为 .js. 在库模式下，所有 import.meta.env.* 用法在构建生产时都会被静态替换。但是，process.env.* 的用法不会被替换，所以你的库的使用者可以动态地更改它。</p></blockquote><h3 id="进阶基础路径选项" tabindex="-1">进阶基础路径选项 <a class="header-anchor" href="#进阶基础路径选项" aria-label="Permalink to &quot;进阶基础路径选项&quot;">​</a></h3><p>实验性</p><h2 id="部署静态站点" tabindex="-1">部署静态站点 <a class="header-anchor" href="#部署静态站点" aria-label="Permalink to &quot;部署静态站点&quot;">​</a></h2><h2 id="环境变量和模式" tabindex="-1">环境变量和模式 <a class="header-anchor" href="#环境变量和模式" aria-label="Permalink to &quot;环境变量和模式&quot;">​</a></h2><h3 id="环境变量" tabindex="-1">环境变量 <a class="header-anchor" href="#环境变量" aria-label="Permalink to &quot;环境变量&quot;">​</a></h3><blockquote><p>Vite 在一个特殊的 import.meta.env 对象上暴露环境变量</p></blockquote><ul><li>import.meta.env.MODE: {string} 应用运行的模式。</li><li>import.meta.env.BASE_URL: {string} 部署应用时的基本 URL。他由base 配置项决定。</li><li>import.meta.env.PROD: {boolean} 应用是否运行在生产环境。</li><li>import.meta.env.DEV: {boolean} 应用是否运行在开发环境 (永远与 import.meta.env.PROD相反)。</li><li>import.meta.env.SSR: {boolean} 应用是否运行在 server 上</li></ul><p>在生产环境中，这些环境变量会在构建时被静态替换，因此，在引用它们时请使用完全静态的字符串。动态的 key 将无法生效。例如，动态 key 取值 <code>import.meta.env[key]</code> 是无效的。</p><h3 id="env" tabindex="-1">.env <a class="header-anchor" href="#env" aria-label="Permalink to &quot;.env&quot;">​</a></h3><p>Vite 使用 dotenv 从你的 环境目录 中的下列文件加载额外的环境变量.</p><p>加载的环境变量也会通过 import.meta.env 以字符串形式暴露给客户端源码. 但出于安全考虑只有以 VITE_ 为前缀的变量才会暴露给经过 vite 处理的代码</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.env</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                # 所有情况下都会加载</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.env.local</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          # 所有情况下都会加载，但会被 git 忽略</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.env.[mode]</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         # 只在指定模式下加载</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.env.[mode].local</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   # 只在指定模式下加载，但会被 git 忽略</span></span></code></pre></div><ul><li>一份用于指定模式的文件（例如 .env.production）会比通用形式的优先级更高（例如 .env）。</li><li>另外，Vite 执行时已经存在的环境变量有最高的优先级，不会被 .env 类文件覆盖。例如当运行 VITE_SOME_KEY=123 vite build 的时候。</li><li>.env 类文件会在 Vite 启动一开始时被加载，而改动会在重启服务器后生效。</li></ul><p>让添加的环境变量获得ts提示</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">reference</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> types</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;vite/client&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ImportMetaEnv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  readonly</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> VITE_APP_TITLE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 更多环境变量...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ImportMeta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  readonly</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> env</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ImportMetaEnv</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="模式" tabindex="-1">模式 <a class="header-anchor" href="#模式" aria-label="Permalink to &quot;模式&quot;">​</a></h3><p>默认情况下，开发服务器 (dev 命令) 运行在 development (开发) 模式，而 build 命令则运行在 production (生产) 模式</p><p>模式 是一个更广泛的概念，而不仅仅是开发和生产， 通过传递 <code>--mode</code> 选项标志来覆盖命令使用的默认模式</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vite</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> build</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --mode</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> staging</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 这是vite回去加载.env.staging文件</span></span></code></pre></div><h2 id="服务端渲染" tabindex="-1">服务端渲染 <a class="header-anchor" href="#服务端渲染" aria-label="Permalink to &quot;服务端渲染&quot;">​</a></h2><h2 id="后端集成" tabindex="-1">后端集成 <a class="header-anchor" href="#后端集成" aria-label="Permalink to &quot;后端集成&quot;">​</a></h2><h2 id="配置参考" tabindex="-1">配置参考 <a class="header-anchor" href="#配置参考" aria-label="Permalink to &quot;配置参考&quot;">​</a></h2>`,95)]))}const m=s(h,[["render",k]]);export{g as __pageData,m as default};
