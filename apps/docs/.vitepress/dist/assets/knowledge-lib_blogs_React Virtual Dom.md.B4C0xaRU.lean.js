import{a2 as e,t as o,ao as i,q as t}from"./chunks/framework.tQiMsDJj.js";const E=JSON.parse('{"title":"Virtual DOM是什么","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge-lib/blogs/React Virtual Dom.md","filePath":"knowledge-lib/blogs/React Virtual Dom.md"}'),l={name:"knowledge-lib/blogs/React Virtual Dom.md"};function c(n,a,r,m,p,s){return t(),o("div",null,a[0]||(a[0]=[i('<h1 id="virtual-dom是什么" tabindex="-1">Virtual DOM是什么 <a class="header-anchor" href="#virtual-dom是什么" aria-label="Permalink to &quot;Virtual DOM是什么&quot;">​</a></h1><p>是一种编程理念，将真实UI节点抽象成对象，与真实DOM进行同步，比如ReactDOM</p><ul><li>UI节点抽象：因为提供了对DOM的抽象，所以在web开发中，通常不需要调用DOM API。也因为抽象，所以Reac也可以开发Native(RN) <ul><li><img src="https://imagehost-1311720054.cos.ap-nanjing.myqcloud.com/blog/%E5%8D%9A%E5%AE%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20220902104703498.png" alt="image-20220902104703498"></li></ul></li><li>Virtual DOM渲染页面 <ul><li><img src="https://imagehost-1311720054.cos.ap-nanjing.myqcloud.com/blog/%E5%8D%9A%E5%AE%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20220902104028761.png" alt="image-20220902104028761"></li><li>原生DOM更新：DOM API调用更新UI</li><li>Virtual DOM更新： <ul><li>每次render都会产生一份新的 react dom</li><li>新旧reactn dom比较，从而确定进行多少变更</li><li>确定最优策略后调用dom api更新UI</li><li><em>?</em> 虽然看似步骤多，但在实际复杂项目，频繁操作原生DOM，引起重绘等问题</li></ul></li><li>优势： <ul><li>高效的diff实现更新</li><li>可维护性和编程思维上，数据驱动视图</li></ul></li></ul></li></ul><h1 id="vdom-diff" tabindex="-1">VDOM Diff <a class="header-anchor" href="#vdom-diff" aria-label="Permalink to &quot;VDOM Diff&quot;">​</a></h1><blockquote><p>组件级别的比较</p></blockquote><p><img src="https://imagehost-1311720054.cos.ap-nanjing.myqcloud.com/blog/%E5%8D%9A%E5%AE%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20220902105001230.png" alt="image-20220902105001230"></p><p>直接删除D组件，不判断子组件EF是否相同，因为实际相同的可能性很小，不如直接删掉重新创建</p><blockquote><p>元素级别的比较</p></blockquote><p><strong>创建节点</strong></p><p><img src="https://imagehost-1311720054.cos.ap-nanjing.myqcloud.com/blog/%E5%8D%9A%E5%AE%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20220902105157117.png" alt="image-20220902105157117"></p><p><img src="https://imagehost-1311720054.cos.ap-nanjing.myqcloud.com/blog/%E5%8D%9A%E5%AE%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20220902105231533.png" alt="image-20220902105231533"></p><p><strong>删除子节点</strong></p><p><img src="https://imagehost-1311720054.cos.ap-nanjing.myqcloud.com/blog/%E5%8D%9A%E5%AE%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20220902105256898.png" alt="image-20220902105256898"></p><p><img src="https://imagehost-1311720054.cos.ap-nanjing.myqcloud.com/blog/%E5%8D%9A%E5%AE%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20220902105312186.png" alt="image-20220902105312186"></p><p><strong>移动节点</strong></p><p><img src="https://imagehost-1311720054.cos.ap-nanjing.myqcloud.com/blog/%E5%8D%9A%E5%AE%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20220902105331992.png" alt="image-20220902105331992"></p><p>将子节点3前每个都向后移动，而不是将3移动到前面</p><p><img src="https://imagehost-1311720054.cos.ap-nanjing.myqcloud.com/blog/%E5%8D%9A%E5%AE%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20220902105353422.png" alt="image-20220902105353422"></p><h2 id="如何看源码" tabindex="-1">如何看源码 <a class="header-anchor" href="#如何看源码" aria-label="Permalink to &quot;如何看源码&quot;">​</a></h2><p>动态注入：在源码中只是声明，具体实现在其它包中如react-dom或react-native</p><p>reac-dom渲染节点：嵌套方式</p><h1 id="react-reconciliation协调" tabindex="-1">React Reconciliation协调 <a class="header-anchor" href="#react-reconciliation协调" aria-label="Permalink to &quot;React Reconciliation协调&quot;">​</a></h1><p>react利用virtual DOM将内存中的虚拟dom转换成真实dom的过程，最重要，最核心</p><h2 id="stack-reconciler-栈协调" tabindex="-1">stack Reconciler 栈协调 <a class="header-anchor" href="#stack-reconciler-栈协调" aria-label="Permalink to &quot;stack Reconciler 栈协调&quot;">​</a></h2><p><img src="https://imagehost-1311720054.cos.ap-nanjing.myqcloud.com/blog/%E5%8D%9A%E5%AE%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20220902110646321.png" alt="image-20220902110646321"></p><p>示例：</p><p><img src="https://imagehost-1311720054.cos.ap-nanjing.myqcloud.com/blog/%E5%8D%9A%E5%AE%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20220902111458621.png" alt="image-20220902111458621"></p><p><img src="https://imagehost-1311720054.cos.ap-nanjing.myqcloud.com/blog/%E5%8D%9A%E5%AE%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20220902111611402.png" alt="image-20220902111611402"></p><p>第一次render</p><p><img src="https://imagehost-1311720054.cos.ap-nanjing.myqcloud.com/blog/%E5%8D%9A%E5%AE%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20220902112125100.png" alt="image-20220902112125100"></p><p><img src="https://imagehost-1311720054.cos.ap-nanjing.myqcloud.com/blog/%E5%8D%9A%E5%AE%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20220902112222071.png" alt="image-20220902112222071"></p><p><img src="https://imagehost-1311720054.cos.ap-nanjing.myqcloud.com/blog/%E5%8D%9A%E5%AE%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20220902112242039.png" alt="image-20220902112242039"></p><p>更新</p><p>组件更新时一气呵成，不可阻断，当组件比较复杂，这时发生用户输入、点击，因为浏览器优先处理渲染或更新，会让用户感到卡顿</p><p>setState在大部分情况下是异步的，当setState时在更新会立即执行，否则放入dirty队列，因为react执行的代码都是宏任务，如果是微任务promise中调用setState会立即执行 <em>？</em></p><h2 id="fiber-reconciler" tabindex="-1">Fiber Reconciler <a class="header-anchor" href="#fiber-reconciler" aria-label="Permalink to &quot;Fiber Reconciler&quot;">​</a></h2><p>实现连续的更新，stack是断断续续的更新</p><p>stack和Fiber</p><h1 id="react-new-component-lifecycle" tabindex="-1">React new Component Lifecycle <a class="header-anchor" href="#react-new-component-lifecycle" aria-label="Permalink to &quot;React new Component Lifecycle&quot;">​</a></h1><p>老</p><p>新</p><p>因为fiber,要求组件渲染之前需要是纯函数行为不能setState或异步，willcomponentMount滥用</p><h2 id="新版组件升级" tabindex="-1">新版组件升级 <a class="header-anchor" href="#新版组件升级" aria-label="Permalink to &quot;新版组件升级&quot;">​</a></h2><p>17之后不行</p><h1 id="hooks" tabindex="-1">HOOKs <a class="header-anchor" href="#hooks" aria-label="Permalink to &quot;HOOKs&quot;">​</a></h1><h2 id="hooks使命" tabindex="-1">Hooks使命 <a class="header-anchor" href="#hooks使命" aria-label="Permalink to &quot;Hooks使命&quot;">​</a></h2><h2 id="hooks原理" tabindex="-1">Hooks原理 <a class="header-anchor" href="#hooks原理" aria-label="Permalink to &quot;Hooks原理&quot;">​</a></h2><p>no magic, just arrays</p>',48)]))}const h=e(l,[["render",c]]);export{E as __pageData,h as default};
