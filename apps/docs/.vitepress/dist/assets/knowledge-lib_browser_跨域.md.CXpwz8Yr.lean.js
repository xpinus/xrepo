import{a2 as i,t as a,ao as l,q as n}from"./chunks/framework.tQiMsDJj.js";const c=JSON.parse('{"title":"跨域问题","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge-lib/browser/跨域.md","filePath":"knowledge-lib/browser/跨域.md"}'),e={name:"knowledge-lib/browser/跨域.md"};function t(p,s,o,h,r,k){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="跨域问题" tabindex="-1">跨域问题 <a class="header-anchor" href="#跨域问题" aria-label="Permalink to &quot;跨域问题&quot;">​</a></h1><h2 id="浏览器的同源策略" tabindex="-1">浏览器的同源策略 <a class="header-anchor" href="#浏览器的同源策略" aria-label="Permalink to &quot;浏览器的同源策略&quot;">​</a></h2><blockquote><p>首先了解下浏览器的同源策略 同源策略<code>SOP（Same origin policy）</code>是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到<code>XSS</code>、<code>CSFR</code>等攻击。所谓同源是指&quot;<strong>协议+域名+端口</strong>&quot;三者相同，即便两个不同的域名指向同一个<code>ip</code>地址，也非同源</p></blockquote><p>存在跨域问题的场景：</p><ol><li>资源跳转： A链接、重定向、表单提交</li><li>资源嵌入： <code>&lt;link&gt;、&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;</code>等dom标签，还有样式中<code>background:url()、@font-face()</code>等文件外链</li><li>脚本请求： js发起的ajax请求、dom和js对象的跨域操作等</li></ol><p>同源策略限制以下几种行为： 1.) Cookie、LocalStorage 和 IndexDB 无法读取 2.) DOM 和 Js对象无法获得 3.) AJAX 请求不能发送</p><h2 id="请求跨域" tabindex="-1">请求跨域 <a class="header-anchor" href="#请求跨域" aria-label="Permalink to &quot;请求跨域&quot;">​</a></h2><ol><li><strong>jsonp跨域</strong></li></ol><blockquote><p>原理：利用script标签加载完成后会自动执行的特性，后端返回携带数据的代码，触发执行前端已有的函数</p></blockquote><p>缺点：只能实现get请求</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 动态创建一个script</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> script </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;script&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">script.type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;text/javascript&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">script.src </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.head.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(script);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 回调执行函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JSON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stringify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(res));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 服务端返回</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">handleCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;status&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;user&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;admin&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><ol start="2"><li><strong>跨域资源共享（CORS）</strong></li></ol><p>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。</p><p>cors规定了三种不同的交互模式，三种模式的影响越来越大，要求也越来越严格</p><ul><li>简单请求 <ul><li>条件 <ul><li>get post head</li><li>没有额外的自定义字段</li><li>content-type: text/plain或multipart/form-data/application/x-www-form-urlencoded</li></ul></li><li>规范 <ul><li>请求头中自动添加<code>Origin</code></li><li>服务器响应头包含<code>Access-Control-Allow-Origin</code></li></ul></li></ul></li><li>需要预检的请求 <ul><li>浏览器发送预检请求（不会实际显示出来），询问服务器是否允许 <ul><li>OPTIONS</li></ul></li><li>如果允许，再发送实际请求</li></ul></li><li>附带身份凭证的请求: 默认情况下跨域不会附带cookie <ul><li>如果要携带 <ul><li>xhr: <code>withCredentials: true</code></li><li>fetch: <code>credentials: &#39;include&#39;</code></li></ul></li><li>会发送预检请求 <ul><li>允许服务器设置<code>Access-Control-Allow-Credentials: true</code></li><li>这种模式下，服务器不得设置<code>Access-Control-Allow-Origin</code>为<code>*</code></li></ul></li></ul></li></ul><p><strong>补充</strong> 在跨域时js只能拿到一些基础的响应头，<code>Access-Control-Expose-Headers</code>设置允许浏览器访问的头的白名单\`</p><ol start="3"><li><strong>代理跨域</strong></li></ol><ul><li>通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</li><li>开发时采用的proxy也是代理跨域</li></ul><ol start="4"><li><strong>WebSocket协议跨域</strong></li></ol><p>WebSocket是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。</p><h2 id="跨标签页通信" tabindex="-1">跨标签页通信 <a class="header-anchor" href="#跨标签页通信" aria-label="Permalink to &quot;跨标签页通信&quot;">​</a></h2><p><a href="https://juejin.cn/post/7087933110678978573" target="_blank" rel="noreferrer">多个标签页之间的通信</a><a href="https://kaifeiji.cc/post/interactions-between-windows-postmessage-and-broadcastchannel/" target="_blank" rel="noreferrer">https://kaifeiji.cc/post/interactions-between-windows-postmessage-and-broadcastchannel/</a></p><ol><li><code>Broadcast Channel API</code>: 广播</li><li>postMessage: 一般用于定向传递数据 用法：postMessage(data,origin)方法接受两个参数</li></ol><ul><li>data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。</li><li>origin： 协议+主机+端口号，也可以设置为&quot;*&quot;，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为&quot;/&quot;。</li></ul><ol start="3"><li>service worker</li><li><code>sharedWorker</code></li><li><code>localStorage</code>： window.onstorage事件监听</li><li>cookie\\indexdb轮询</li><li>websocket: 需要服务器中转</li></ol><h2 id="其它-了解" tabindex="-1">其它（了解） <a class="header-anchor" href="#其它-了解" aria-label="Permalink to &quot;其它（了解）&quot;">​</a></h2><ol><li>document.domain + iframe</li></ol><blockquote><p>此方案仅限主域相同，子域不同的跨域应用场景</p></blockquote><blockquote><p>原理：页面和页面内iframe都通过js强制设置document.domain为基础主域，就实现了同域</p></blockquote><p><a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noreferrer">更多</a></p><ul><li><p>前端</p><ul><li>原生 ajax ： axios.defaults.withCredentials = true</li><li>axios：axios.defaults.withCredentials = true</li></ul></li><li><p>服务端</p><ul><li><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Access-Control-Allow-Credentials&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;true&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 后端允许发送Cookie</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Access-Control-Allow-Origin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;http://www.domain1.com&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 允许访问的域（协议+域名+端口）</span></span></code></pre></div></li></ul></li></ul><p>nginx 代理跨域</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#proxy服务器</span></span>
<span class="line"><span>server {</span></span>
<span class="line"><span>    listen       81;</span></span>
<span class="line"><span>    server_name  www.domain1.com;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    location / {</span></span>
<span class="line"><span>        proxy_pass   http://www.domain2.com:8080;  #反向代理</span></span>
<span class="line"><span>        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span></span>
<span class="line"><span>        index  index.html index.htm;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span></span>
<span class="line"><span>        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*</span></span>
<span class="line"><span>        add_header Access-Control-Allow-Credentials true;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div>`,34)]))}const g=i(e,[["render",t]]);export{c as __pageData,g as default};
