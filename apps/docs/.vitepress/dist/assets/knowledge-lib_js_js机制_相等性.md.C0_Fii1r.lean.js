import{a3 as a,t as s,ao as l,q as e}from"./chunks/framework.Dt9YBBJv.js";const c=JSON.parse('{"title":"相等算法","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge-lib/js/js机制/相等性.md","filePath":"knowledge-lib/js/js机制/相等性.md"}'),t={name:"knowledge-lib/js/js机制/相等性.md"};function n(o,i,h,p,r,d){return e(),s("div",null,i[0]||(i[0]=[l('<h1 id="相等算法" tabindex="-1">相等算法 <a class="header-anchor" href="#相等算法" aria-label="Permalink to &quot;相等算法&quot;">​</a></h1><p>JavaScript 提供三种不同的值比较运算：</p><ul><li><code>===</code>——严格相等（三个等号）</li><li><code>==</code>——宽松相等（两个等号）</li><li><code>Object.is()</code></li></ul><h2 id="宽松相等" tabindex="-1">宽松相等 <code>==</code> <a class="header-anchor" href="#宽松相等" aria-label="Permalink to &quot;宽松相等 `==`&quot;">​</a></h2><ul><li>在比较两个操作数时，双等号（==）将执行类型转换</li><li>对 NaN、-0 和 +0 进行特殊处理（故 NaN != NaN，且 -0 == +0）</li><li>对应JS相等算法中的<code>IsLooselyEqual</code></li></ul><p>行为如下：</p><ol><li>操作数类型相同： <ol><li>对象Object时：比较两个对象的内存地址</li><li>数字Number时：比较两个数字的值, NaN != NaN，且 -0 == +0</li><li>字符串String、布尔Boolean、大整形BigInt、Symbol时：比较两个的值</li></ol></li><li>如果其中一个操作数为<code>null</code>或<code>undefined</code>, 只有另一个也必须是<code>null</code>或<code>undefined</code>才为<code>true</code></li><li>如果其中一个操作数是对象，另一个是原始值，则将对象转换为原始值</li><li>这是两个操作时都为原始值（String、Number、Boolean、BigInt、Symbol） <ol><li>如果类型相等，则根据规则1进行比较</li><li>符号只会与同一符号相等</li><li>如果一个是boolean，另一个不是，则将布尔值转换为数字 1 或 0</li><li>数字与字符串：字符串转换为数字。转换失败的结果为 NaN，这将保证相等比较为 false</li><li>数字与大整型：按数字的值进行比较。如果数字为±Infinity或NaN，返回 false</li><li>字符串与大整型：使用BigInt将字符串转换为大整型数。如果转换失败，返回 false</li></ol></li></ol><h2 id="严格相等" tabindex="-1">严格相等 <code>===</code> <a class="header-anchor" href="#严格相等" aria-label="Permalink to &quot;严格相等 `===`&quot;">​</a></h2><ul><li>比较时不进行类型转换；如果类型不同，则返回 false</li><li>NaN != NaN，且 -0 == +0</li><li>对应JS相等算法中的<code>IsStrictlyEqual</code></li></ul><p>数组索引查找方法使用严格相等, 包括 Array.prototype.indexOf()、Array.prototype.lastIndexOf()、TypedArray.prototype.index()、TypedArray.prototype.lastIndexOf() 和 case 匹配</p><h2 id="同值相等-object-is" tabindex="-1">同值相等 <code>Object.is()</code> <a class="header-anchor" href="#同值相等-object-is" aria-label="Permalink to &quot;同值相等 `Object.is()`&quot;">​</a></h2><ul><li>不进行类型转换</li><li>NaN 等于 NaN</li><li>+0 不等于 -0</li><li>对应JS相等算法中的<code>SameValue</code></li></ul><h2 id="零值相等" tabindex="-1">零值相等 <a class="header-anchor" href="#零值相等" aria-label="Permalink to &quot;零值相等&quot;">​</a></h2><ul><li>与同值相等的区别在于其将 -0 和 0 视作相等</li><li>与严格相等的区别在于其将 NaN 视作是相等的</li><li>这使得它在搜索期间通常具有最实用的行为, 被用于 Array.prototype.includes()、TypedArray.prototype.includes()，以及 Map 和 Set 的需要比较键的相等性的方法</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sameValueZero</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, y);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="面试题" tabindex="-1">面试题 <a class="header-anchor" href="#面试题" aria-label="Permalink to &quot;面试题&quot;">​</a></h2><blockquote><p>==和===有什么区别</p></blockquote>',17)]))}const u=a(t,[["render",n]]);export{c as __pageData,u as default};
