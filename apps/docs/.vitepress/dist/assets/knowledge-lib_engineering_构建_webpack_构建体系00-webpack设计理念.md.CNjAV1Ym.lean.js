import{a2 as e,t as i,aq as o,q as a}from"./chunks/framework.jAttmLhR.js";const p="/assets/pack.BBXq2JQv.png",d=JSON.parse('{"title":"webpack设计理念","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge-lib/engineering/构建/webpack/构建体系00-webpack设计理念.md","filePath":"knowledge-lib/engineering/构建/webpack/构建体系00-webpack设计理念.md"}'),c={name:"knowledge-lib/engineering/构建/webpack/构建体系00-webpack设计理念.md"};function t(n,l,r,k,s,b){return a(),i("div",null,l[0]||(l[0]=[o('<h1 id="webpack设计理念" tabindex="-1">webpack设计理念 <a class="header-anchor" href="#webpack设计理念" aria-label="Permalink to &quot;webpack设计理念&quot;">​</a></h1><blockquote><p>Webpack 本质上是一个函数，它接受一个配置信息作为参数，执行后返回一个 compiler 对象，调用 compiler 对象中的 run 方法就会启动编译。run 方法接受一个回调，可以用来查看编译过程中的错误信息或编译信息</p></blockquote><p><img src="'+p+'" alt="pack"></p><blockquote><p>核心思想</p></blockquote><ol><li>首先，根据配置信息（webpack.config.js）找到入口文件（src/index.js）</li><li>到入口文件所依赖的模块，并收集关键信息：比如路径、源代码、它所依赖的模块等 <ol><li>Loader 系统 本质上就是接收资源文件，并对其进行转换，最终输出转换后的文件</li></ol></li><li>根据上一步得到的信息，生成最终输出到硬盘中的文件（dist）： 包括 modules 对象、require 模版代码、入口执行文件等</li></ol><p>除此之外，打包过程中也有一些特定的时机需要处理，比如：</p><ul><li>在打包前需要校验用户传过来的参数，判断格式是否符合要求</li><li>在打包过程中，需要知道哪些模块可以忽略编译，直接引用 cdn 链接</li><li>在编译完成后，需要将输出的内容插入到 html 文件中</li><li>在输出到硬盘前，需要先清空 dist 文件夹</li></ul><p>这个时候需要一个可插拔的设计，方便给社区提供可扩展的接口 —— <code>Plugin 系统</code>, 本质上就是一种事件流的机制，到了固定的时间节点就广播特定的事件，用户可以在事件内执行特定的逻辑，类似于生命周期</p><blockquote><p>架构设计</p></blockquote><p>需要建立一套事件流的机制来管控整个打包过程，大致可以分为三个阶段：</p><ul><li>打包开始前的准备工作</li><li>打包过程中（也就是编译阶段）</li><li>打包结束后（包含打包成功和打包失败）</li></ul><p>实现方式：Tapable</p><blockquote><p>具体实现：</p></blockquote><ol><li>搭建结构，读取配置参数</li><li>用配置参数对象初始化 Compiler 对象</li><li>挂载配置文件中的插件</li><li>执行 Compiler 对象的 run 方法开始执行编译</li><li>根据配置文件中的 entry 配置项找到所有的入口</li><li>从入口文件出发，调用配置的 loader 规则，对各模块进行编译</li><li>找出此模块所依赖的模块，再对依赖模块进行编译</li><li>等所有模块都编译完成后，根据模块之间的依赖关系，组装代码块 chunk</li><li>把各个代码块 chunk 转换成一个一个文件加入到输出列表</li><li>确定好输出内容之后，根据配置的输出路径和文件名，将文件内容写入到文件系统</li></ol>',14)]))}const m=e(c,[["render",t]]);export{d as __pageData,m as default};
