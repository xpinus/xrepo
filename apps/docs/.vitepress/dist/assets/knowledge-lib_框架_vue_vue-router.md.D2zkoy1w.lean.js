import{a2 as i,t as a,aq as n,q as l}from"./chunks/framework.jAttmLhR.js";const o=JSON.parse('{"title":"vue-router","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge-lib/框架/vue/vue-router.md","filePath":"knowledge-lib/框架/vue/vue-router.md"}'),t={name:"knowledge-lib/框架/vue/vue-router.md"};function h(e,s,p,k,r,d){return l(),a("div",null,s[0]||(s[0]=[n(`<h1 id="vue-router" tabindex="-1">vue-router <a class="header-anchor" href="#vue-router" aria-label="Permalink to &quot;vue-router&quot;">​</a></h1><h2 id="内置组件和函数" tabindex="-1">内置组件和函数 <a class="header-anchor" href="#内置组件和函数" aria-label="Permalink to &quot;内置组件和函数&quot;">​</a></h2><ul><li>RouterLink <ul><li>activeClass： 当链接所指向的路径匹配当前路由路径时，应用于该链接的 CSS 类</li><li>exactActiveClass：当链接所指向的路径精确匹配当前路由路径时，应用于该链接的 CSS 类</li></ul></li><li>RouterView： 视图或路由出口 RouterView 组件暴露了一个插槽（作用域插槽），这个插槽可以用来获取当前匹配的路由组件, 方便扩展一些其他的功能。</li></ul><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">router-view</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-slot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;{ Component }&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">transition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">keep-alive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">component</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Component&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">keep-alive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">transition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">router-view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><ul><li>useRouter和useRoute: 在 setup 中没有 this，因此无法像 Vue2 那样通过 this.router或者this. route 来访问路由实例和当前路由。与之替代的就是通过 useRouter 和 useRoute 这两个内置函数。</li><li>useLink：用于自定义导航组件的时候使用</li></ul><h2 id="路由模式" tabindex="-1">路由模式 <a class="header-anchor" href="#路由模式" aria-label="Permalink to &quot;路由模式&quot;">​</a></h2><p>vue-router 有 3 种路由模式：</p><ul><li>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器</li><li>history : 依赖 HTML5 History API 和服务器配置</li><li>abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li></ul><h3 id="hash-模式" tabindex="-1">hash 模式 <a class="header-anchor" href="#hash-模式" aria-label="Permalink to &quot;hash 模式&quot;">​</a></h3><p>早期的前端路由的实现就是基于 location.hash 来实现的。</p><p>location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 &#39;#search&#39;：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">https://www.word.com#search</span></span></code></pre></div><ul><li>hash 路由模式的实现主要是基于下面几个特性： <ul><li>URL 中 hash 值只是客户端的一种状态，<strong>Hash 的变化不会请求服务器</strong>，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li><li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制 hash 的切换；</li><li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用js来对<code>loaction.hash</code>进行赋值，改变 URL 的 hash 值</li><li>我们可以使用<code>hashchange</code>事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。</li></ul></li><li>优点： <ul><li>通用性好，支持各种浏览器</li><li>不需要后端服务器做配合</li></ul></li><li>缺点： <ul><li>不好看</li><li>不支持SEO。搜索引擎会直接抛弃#号后面的</li></ul></li></ul><h3 id="history-模式" tabindex="-1">history 模式 <a class="header-anchor" href="#history-模式" aria-label="Permalink to &quot;history 模式&quot;">​</a></h3><p><code>HTML5</code>提供了 <code>History API</code> 来实现 URL 的变化。<strong>hashchange，你只能改变#后面的url片段，而history api则给了前端完全的自由</strong></p><ul><li>优点：路径比较正规</li><li>缺点： <ul><li>如果没有后端渲染的话，还是不支持SEO</li><li>兼容性不如 hash</li></ul></li></ul><p>History API：</p><ul><li>history.pushState(state, title, url)：将一个状态推入到历史堆栈里面</li><li>history.replaceState(state, title, url)：替换当前历史堆栈最上面的状态</li><li>window.onpopstate：这是一个事件，当用户点击浏览器的前进或者后退按钮的时候，会触发该事件</li></ul><p><strong>实现原理</strong></p><ul><li>拦截链接点击事件 <ul><li>客户端路由器会拦截页面上的所有链接点击事件（通常是通过阻止链接的默认行为 event.preventDefault( )）</li><li>取而代之的是，路由器使用 history.pushState 或 history.replaceState 更新 URL。</li></ul></li><li>URL 变化处理: <ul><li>当 URL 变化时，路由器会捕捉到这个变化。 <ul><li>路由器不会发出新的 HTTP 请求，而是根据新的 URL 查找预先定义好的路由规则，并加载相应的视图组件</li></ul></li></ul></li></ul><p><strong>History存在的问题</strong></p><p>一旦刷新，就会报 404 错误。</p><p>原因：刷新的时候，是会请求服务器的。但是服务器并没有这个后端路由，这个仅仅是一个前端路由。</p><p>解决： 需要在服务器（nginx）上面做一些配置。添加一个回退路由，如果 URL 不匹配任何的静态资源，回退到首页。</p><h3 id="memory模式" tabindex="-1">Memory模式 <a class="header-anchor" href="#memory模式" aria-label="Permalink to &quot;Memory模式&quot;">​</a></h3><p>无论是 Hash 也好、History API 也好，本质上都是基于浏览器的特性来实现的。</p><p>而 Memory 模式一般用于非浏览器环境，例如 Node 或者 SSR. 因为是非浏览器环境，所以不会有 URL 交互也不会自动触发初始导航。</p><p>该模式用 createMemoryHistory( ) 创建，并且需要在调用 app.use(router) 之后手动 push 到初始导航。</p><h2 id="导航守卫" tabindex="-1">导航守卫 <a class="header-anchor" href="#导航守卫" aria-label="Permalink to &quot;导航守卫&quot;">​</a></h2><blockquote><p>所谓导航守卫，就是在当你进行导航的时候将其拦截下来，从而方便做一些其他的事情</p></blockquote><ul><li>全局的路由钩子函数：beforeEach、beforeResolve、afterEach</li><li>单个的路由钩子函数：beforeEnter</li><li>组件内的路由钩子函数：beforeRouteEnter、beforeRouteLeave、beforeRouteUpdate</li></ul><p>整体的执行顺序：</p><ul><li>组件离开守卫</li><li>全局前置守卫</li><li>路由级别守卫</li><li>全局解析守卫</li><li>全局后置守卫</li><li>组件进入守卫 如果是组件复用，参数变化的情况，执行顺序如下：</li><li>全局前置守卫</li><li>组件更新守卫</li><li>全局解析守卫</li><li>全局后置守卫</li></ul><h3 id="全局守卫" tabindex="-1">全局守卫 <a class="header-anchor" href="#全局守卫" aria-label="Permalink to &quot;全局守卫&quot;">​</a></h3><ul><li>beforeEach：全局前置守卫，会在解析组件守卫和异步路由组件之前被调用</li><li>beforeResolve：全局解析守卫，在导航被确认之前，但在所有组件内守卫和异步路由组件被解析之后调用,上面两个其实就是执行的时机一前一后</li><li>afterEach：全局后置守卫，在导航确认后触发的钩子函数。该钩子函数执行后会触发 DOM 更新，用户看到新的页面。 <ul><li>思考🤔：既然导航都已经确认了，这里安插一个守卫干嘛呢？</li><li>全局后置守卫经常用于如下的场景： <ul><li>记录页面访问历史：可以使用 afterEach 来记录用户访问的页面，以便进行统计或分析。</li><li>关闭加载指示器：在 beforeEach 中开启加载指示器，在 afterEach 中关闭它，以提供更好的用户体验。</li><li>页面切换动画：在 afterEach 中触发页面切换动画或其他视觉效果，以提升用户体验。</li><li>更新文档标题：在导航完成后更新页面标题，以反映当前页面内容</li></ul></li></ul></li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">beforeEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 返回 false 以取消导航</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;全局路由——to：&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, to)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  document.title </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> to.meta.title</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>应用：</p><ul><li>设置浏览器的title 虽然现在的浏览器都是多标签的形式，每个窗口的title展示的空间都非常小，基本显示不了几个字，但是也还是要设置一下。那么就可以在这里统一设置一下。</li><li>登录验证、权限验证 有些页面必须登录后才能访问，比如用户中心、管理后台等，有些页面还需要验证具体的权限，那么都可以在这里进行。</li></ul><h3 id="路由守卫" tabindex="-1">路由守卫 <a class="header-anchor" href="#路由守卫" aria-label="Permalink to &quot;路由守卫&quot;">​</a></h3><p>beforeEnter：针对特定路由设置的守卫，在某个路由配置中设置</p><ul><li>beforeEnter 守卫只在进入路由时触发，不会在 params、query 或 hash 改变时触发</li><li>如果放在父级路由上，路由在具有相同父级的子路由之间移动时，它不会被触发</li></ul><h3 id="组件守卫" tabindex="-1">组件守卫 <a class="header-anchor" href="#组件守卫" aria-label="Permalink to &quot;组件守卫&quot;">​</a></h3><p>提供了三种监听方式：</p><ul><li>beforeRouteEnter：进入了该导航，组件开始渲染之前 <ul><li>只能在 option API 里面使用，因为 该守卫在导航确认前被调用，因此即将登场的新组件还没被创建，那么就更不用说 setup 了。 因为现在 setup 非常流行，script setup 更加诱人，所以 beforeRouteEnter 基本被废掉了。</li></ul></li><li>beforeRouteUpdate：当前路由改变，但是该组件被复用时调用，例如对于一个带有动态参数的路径 /users/:id，在 /users/1 和 /users/2 之间跳转的时候会触发 <ul><li>虽然可以在 setup 里面使用，但是受到拖累，基本比较鸡肋。</li></ul></li><li>beforeRouteLeave：离开了该导航，组件失活的时候 <ul><li>可以做一些提示性操作，比如：你真的要离开吗？你真的真的要离开吗？你写的文档还没保存呢！</li></ul></li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { onBeforeRouteLeave } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue-router&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onBeforeRouteLeave</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> answer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">confirm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Do you really want to leave? you have unsaved changes!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">answer) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h2 id="动态路由" tabindex="-1">动态路由 <a class="header-anchor" href="#动态路由" aria-label="Permalink to &quot;动态路由&quot;">​</a></h2><p><strong>需求</strong>：一般路由是在<code> router/index.js</code>里面设置的，这样我们有了一套固定的路由。 但是有的时候我们需要在运行时可以动态设置一些路由，最常见的就是后台管理。 用户登录后，根据用户的角色、权限，加载对应的路由。这样感觉上可以安全一些，另外路由的“体积”也不用那么大。</p><p><strong>实现</strong>：</p><h3 id="动态添加路由" tabindex="-1">动态添加路由 <a class="header-anchor" href="#动态添加路由" aria-label="Permalink to &quot;动态添加路由&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// router/index.js 里面添加动态路由</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addRoute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/about22&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, component: About })</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// main.js 里面添加动态路由</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addRoute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/about33&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./views/home.vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) })</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 添加嵌套路由，可以将路由的 name 作为第一个参数传递</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addRoute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;admin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/admin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, component: Admin })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addRoute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;admin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;settings&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, component: AdminSettings })</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 或</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addRoute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;admin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/admin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  component: Admin,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  children: [{ path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;settings&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, component: AdminSettings }],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 其他组件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { useRouter } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue-router&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">addRoute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 添加动态路由</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addRoute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;about77&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/about77&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./views/home.vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) })</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addRoute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;about66&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/about66&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./views/baseControl.vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) })</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// router.replace(&#39;/about66&#39;)  // 自动跳转</span></span></code></pre></div><p>我们可以在 router/index.js 里面加，也可以在main.js 里面加，也可以在其他地方加，比如登录的组件。</p><blockquote><p>在 router/index.js 和 main.js 里面添加的动态路由，可以在地址栏里面直接刷新就是按F5。 而在其他组件里面添加的动态路由，不支持按F5，除非使用 router.replace 跳转一下。</p></blockquote><h3 id="删除路由" tabindex="-1">删除路由 <a class="header-anchor" href="#删除路由" aria-label="Permalink to &quot;删除路由&quot;">​</a></h3><ul><li>按照名称删除</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addRoute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/about&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;about&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, component: About })</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 删除路由</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeRoute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;about&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><ul><li>利用返回的实例</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> delRoute</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addRoute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(routeRecord)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">delRoute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 删除路由如果存在的话</span></span></code></pre></div><ul><li>以新换旧</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addRoute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/about&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;about&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, component: About })</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这将会删除之前已经添加的路由，因为他们具有相同的名字且名字必须是唯一的</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addRoute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/other&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;about&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, component: Other })</span></span></code></pre></div><h3 id="其它" tabindex="-1">其它 <a class="header-anchor" href="#其它" aria-label="Permalink to &quot;其它&quot;">​</a></h3><ul><li>router.hasRoute(name)：检查路由是否存在。</li><li>router.getRoutes( )：获取一个包含所有路由记录的数组。</li></ul><h2 id="复杂的路由权限设置" tabindex="-1">复杂的路由权限设置 <a class="header-anchor" href="#复杂的路由权限设置" aria-label="Permalink to &quot;复杂的路由权限设置&quot;">​</a></h2><p>比如OA系统、多种角色的权限配置。通常需要后台传来当前用户对应权限的路由表，前端通过调接口拿到后处理(后端处理路由)，里边逻辑很复杂，不好返给前端用户权限，担心路由放到前端不安全。</p><p><strong>思路</strong>：拦截路由-&gt;后台取到路由-&gt;保存路由到<code>localStorage</code>(用户登录进来只会从后台取一次，其余都从本地取,所以用户，只有退出再登录路由才会更新)-&gt;动态添加路由</p><p><a href="https://www.jianshu.com/p/eaa7354ecee2" target="_blank" rel="noreferrer">https://www.jianshu.com/p/eaa7354ecee2</a></p><h2 id="路由传参" tabindex="-1">路由传参 <a class="header-anchor" href="#路由传参" aria-label="Permalink to &quot;路由传参&quot;">​</a></h2><blockquote><p>场景：点击当前页的某个按钮跳转到另一个页面，并将某个值带过去</p></blockquote><p>路由跳转方式</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">//  router-link</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">router-link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/list&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;点击跳转到列表页&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">router-link</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2 js</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$router.push</span></span></code></pre></div><h2 id="_1-直接使用路由属性配置this-router-push实现携带参数跳转" tabindex="-1">1 直接使用路由属性配置<code>this.$router.push</code>实现携带参数跳转 <a class="header-anchor" href="#_1-直接使用路由属性配置this-router-push实现携带参数跳转" aria-label="Permalink to &quot;1 直接使用路由属性配置\`this.$router.push\`实现携带参数跳转&quot;">​</a></h2><ul><li>对应的路由配置(每个路由配置信息以对象的形式保存)</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> VueRouter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue-router&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//引入vue-router</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Vue.config.producionTip </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//阻止启动生产消息</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 开发环境下，Vue 会提供很多警告信息来帮你对付常见的错误与陷阱。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 而在生产环境下，这些警告语句却没有用，反而会增加应用的体积。此外，有些警告检查还有一些小的运行时开销，这在生产环境模式下是可以避免的。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Vue.config.producionTip = false; 可以当做是消息提示的环境配置，false即设置为开发环境下，true即生产环境下</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(VueRouter); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//使用VueRouter，注入到Vue实例中</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VueRotuer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//创建路由对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mode: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;history&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//设置路由模式为history模式</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/user/:id&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设定待传递的值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        name</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;User&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        component</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    User</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//将路由对象添加到vue实例对象中</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ router, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">h</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> h</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(App) }).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$mount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#app&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><ul><li>返送方使用<code>$router.push</code>跳转时，在url中携带参数</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({path:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`/user/\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">id</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}/\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 通过路径添加值</span></span></code></pre></div><ul><li>接收方使用<code>$route.params</code>获取传递过来的值，参数名为配置中设置的名</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>this.$route.params.id</span></span></code></pre></div><h1 id="_2-通过路由属性中的name来匹配路由-然后通过params来传递参数" tabindex="-1">2 通过路由属性中的<code>name</code>来匹配路由，然后通过<code>params</code>来传递参数 <a class="header-anchor" href="#_2-通过路由属性中的name来匹配路由-然后通过params来传递参数" aria-label="Permalink to &quot;2 通过路由属性中的\`name\`来匹配路由，然后通过\`params\`来传递参数&quot;">​</a></h1><ul><li>路由配置无需更改</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>{ </span></span>
<span class="line"><span>    path: &#39;/user&#39;, </span></span>
<span class="line"><span>    name: &#39;User&#39;, </span></span>
<span class="line"><span>    component: User </span></span>
<span class="line"><span>}</span></span></code></pre></div><ul><li>发送方</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>this.$router.push({</span></span>
<span class="line"><span>    name: &#39;User&#39;,</span></span>
<span class="line"><span>    params: { id: id }</span></span>
<span class="line"><span>})</span></span></code></pre></div><ul><li>接收方 <strong>页面刷新时传递参数会消失</strong></li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>this.$route.params.id</span></span></code></pre></div><h2 id="_3-使用路由属性中的path来匹配路由-然后通过query来传递参数" tabindex="-1">3 使用路由属性中的<code>path</code>来匹配路由，然后通过<code>query</code>来传递参数 <a class="header-anchor" href="#_3-使用路由属性中的path来匹配路由-然后通过query来传递参数" aria-label="Permalink to &quot;3 使用路由属性中的\`path\`来匹配路由，然后通过\`query\`来传递参数&quot;">​</a></h2><p><strong>这种情况下<code>query</code>传递的参数会显示在<code>url</code>后面, 如<code>/user?id=？</code>即参数再浏览器刷新时不会丢失！</strong></p><ul><li>路由配置无需更改</li><li>发送方</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>this.$router.push({</span></span>
<span class="line"><span>    path: &#39;/user&#39;,</span></span>
<span class="line"><span>    query: { id: id }</span></span>
<span class="line"><span>})</span></span></code></pre></div><ul><li>接收方一致</li></ul><h2 id="params和query路由传参的区别" tabindex="-1"><code>params</code>和<code>query</code>路由传参的区别 <a class="header-anchor" href="#params和query路由传参的区别" aria-label="Permalink to &quot;\`params\`和\`query\`路由传参的区别&quot;">​</a></h2><p>（1）使用方面</p><ul><li><p><code>query</code>用<code>path</code>来匹配路由，接收参数<code>this.$route.query.name</code>。</p></li><li><p>如果<code>params</code>方式写成<code>path</code>引入，接收的参数会是<code>undefined</code>。</p></li><li><p>用<code>params</code>传参方式的参数用/来间隔显示，如/login/10/tom；</p></li></ul><p>（2）浏览器地址栏显示方面</p><ul><li><code>query</code>传参方式，在地址栏会显示参数；</li><li><code>params</code>传参方式，地址栏不显示参数。</li><li>用<code>query</code>传参方式的参数<code>/login?id=1&amp;name=tom</code>。 注意：如果你在地址栏中手动输入参数后，当页面一刷新时，<code>params</code>的值就消失了。</li></ul><p><strong>将参数直接以 props 的形式传递给组件</strong></p><p>首先在路由配置中开启 props</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> routes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  { path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/user/:userId(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">d+)&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;User&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, component: User, props: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>在组件内部设置 id 这个 props，之后路由参数就会以 props 的形式传递进来</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> props</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineProps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  userId: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    type: String,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    required: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><h2 id="路由匹配语法" tabindex="-1">路由匹配语法 <a class="header-anchor" href="#路由匹配语法" aria-label="Permalink to &quot;路由匹配语法&quot;">​</a></h2><ul><li>静态路由匹配：/about ---&gt; /about</li><li>动态路由匹配：/users/:id ---&gt; /users/1、/users/2</li><li>参数正则： /users/:userId(\\d+) 限制参数的类型,路由后面的参数就只能匹配数字</li><li>重复参数： /product/:name+ 参数:name+ 表示 1 或者多次，* 表示 0 或者多次</li><li>可选参数: /users/:userId?</li></ul><h2 id="其它-1" tabindex="-1">其它 <a class="header-anchor" href="#其它-1" aria-label="Permalink to &quot;其它&quot;">​</a></h2><h3 id="路由别名" tabindex="-1">路由别名 <a class="header-anchor" href="#路由别名" aria-label="Permalink to &quot;路由别名&quot;">​</a></h3><ul><li>兼容旧路径：有些时候需要更新路径，使用别名可以保证旧的路由依然有效</li><li>简化路径：特别是嵌套路由的情况下，路径可能会很长，别名可以简化路径</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    history: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createWebHistory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    routes: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/user/:id/profile&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;user-profile&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            component: UserProfile,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            alias: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/profile/:id&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 配置路由别名, 可以通过 /profile/:id 进行访问</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="命名视图" tabindex="-1">命名视图 <a class="header-anchor" href="#命名视图" aria-label="Permalink to &quot;命名视图&quot;">​</a></h3><p>有些时候会存在这样的需求，那就是<strong>一个路由对应多个组件</strong>，而非一个组件。不同的组件渲染到不同的视图里面，此时需要给视图设置不同的 name 来加以区分。</p><p>如果视图没有设置名字，那么默认为 default.</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>const router = createRouter({</span></span>
<span class="line"><span>  history: createWebHashHistory(),</span></span>
<span class="line"><span>  routes: [</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>      path: &#39;/&#39;,</span></span>
<span class="line"><span>      // 注意这里是 components，多了一个&#39;s&#39;</span></span>
<span class="line"><span>      components: {</span></span>
<span class="line"><span>        default: Home,</span></span>
<span class="line"><span>        // LeftSidebar: LeftSidebar 的缩写</span></span>
<span class="line"><span>        LeftSidebar,</span></span>
<span class="line"><span>        // 它们与 &lt;router-view&gt; 上的 name 属性匹配</span></span>
<span class="line"><span>        RightSidebar,</span></span>
<span class="line"><span>      },</span></span>
<span class="line"><span>    },</span></span>
<span class="line"><span>  ],</span></span>
<span class="line"><span>})</span></span></code></pre></div><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">router-view</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;view left-sidebar&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;LeftSidebar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">router-view</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;view main-content&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">router-view</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;view right-sidebar&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;RightSidebar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span></code></pre></div><h3 id="重定向" tabindex="-1">重定向 <a class="header-anchor" href="#重定向" aria-label="Permalink to &quot;重定向&quot;">​</a></h3><p>通过 redirect 可以配置路由重定向</p><ul><li>字符串: 重定向路径</li><li>对象：可以使用对象来更详细地定义重定向，包括传递路径参数和查询参数</li><li>函数：重定向函数可以根据路由信息<strong>动态</strong>生成重定向目标路径。</li></ul><h3 id="路由元数据" tabindex="-1">路由元数据 <a class="header-anchor" href="#路由元数据" aria-label="Permalink to &quot;路由元数据&quot;">​</a></h3><p>元数据（meta fields）是一种附加到路由配置中的属性，用来存储与路由相关的附加信息。</p><p>经常用于权限控制、标题设置、面包屑导航、路由过渡之类的效果</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">beforeEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 实现权限控制</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (to.meta.requiresAuth </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isLoggedIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/login&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="路由懒加载" tabindex="-1">路由懒加载 <a class="header-anchor" href="#路由懒加载" aria-label="Permalink to &quot;路由懒加载&quot;">​</a></h3><p><code>component: () =&gt; import(&#39;../views/AboutView.vue&#39;)</code></p><p>好处在于：</p><ul><li>当路由被访问的时候才加载对应组件，这样就会更加高效, 因此也没必要在使用异步组件</li><li>进行打包的时候方便做代码分割</li></ul>`,121)]))}const g=i(t,[["render",h]]);export{o as __pageData,g as default};
