import{a3 as a,t as l,ao as i,q as r}from"./chunks/framework.Dt9YBBJv.js";const t="/assets/pipeline.Da45bc57.png",h=JSON.parse('{"title":"AST抽象语法树","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge-lib/engineering/构建/AST/index.md","filePath":"knowledge-lib/engineering/构建/AST/index.md"}'),o={name:"knowledge-lib/engineering/构建/AST/index.md"};function n(s,e,c,p,d,u){return r(),l("div",null,e[0]||(e[0]=[i('<h1 id="ast抽象语法树" tabindex="-1">AST抽象语法树 <a class="header-anchor" href="#ast抽象语法树" aria-label="Permalink to &quot;AST抽象语法树&quot;">​</a></h1><blockquote><p>抽象语法树（Abstract Syntax Tree，AST）是源代码语法结构的一种抽象表示，它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。在代码语法的检查、代码风格的检查、代码的格式化、代码的高亮、代码错误提示、代码自动补全等等场景均有广泛的应用。</p></blockquote><p><a href="https://astexplorer.net/" target="_blank" rel="noreferrer">在线AST尝试</a></p><h2 id="编译器设计篇" tabindex="-1">编译器设计篇 <a class="header-anchor" href="#编译器设计篇" aria-label="Permalink to &quot;编译器设计篇&quot;">​</a></h2><blockquote><p>![TIP] 形而上学的理解下概念</p></blockquote><p>一个完整的编译器整体执行过程可以分为三个步骤：</p><ul><li>Parsing(解析过程)：这个过程要经词法分析、语法分析、构建AST（抽象语法树）一系列操作；</li><li>Transformation（转化过程）：这个过程就是将上一步解析后的内容，按照编译器指定的规则进行处理，形成一个新的表现形式；</li><li>Code Generation（代码生成）：将上一步处理好的内容转化为新的代码；</li></ul><p><img src="'+t+'" alt="AST流程"></p><h3 id="parsing-解析" tabindex="-1">Parsing 解析 <a class="header-anchor" href="#parsing-解析" aria-label="Permalink to &quot;Parsing 解析&quot;">​</a></h3><blockquote><p>解析过程分为2个步骤：词法分析、语法分析。</p></blockquote><ul><li>词法分析 (拆分) <ul><li>词法分析是使用tokenizer(分词器)或者lexer(词法分析器)，将源码拆分成tokens，</li><li>tokens是一个放置对象的数组，其中的每一个对象都可以看做是一个单元（数字，标签，标点，操作符...）的描述信息。</li></ul></li><li>语法分析 (重组) <ul><li>将tokens重新整理成语法相互关联的表达形式 ，这种表达形式一般被称为AST（抽象语法树）</li></ul></li></ul><h3 id="transforming-转化" tabindex="-1">Transforming 转化 <a class="header-anchor" href="#transforming-转化" aria-label="Permalink to &quot;Transforming 转化&quot;">​</a></h3><blockquote><p>这个过程主要是改写AST（抽象语法树），或者根据当前AST（抽象语法树）生成一个新的AST（抽象语法树），这个过程可以是相同语言，或者可以直接将AST（抽象语法树）翻译为其他语言</p></blockquote><p>这个创建的过程就需要遍历这个“树”的节点并读取其内容，由此引出 Traversal(遍历) 和 Visitors (访问器)</p><ul><li>Traversal(遍历)：顾名思义这个过程就是，遍历这个AST（抽象语法树）的所有节点，这个过程使用 深度优先原则，大概执行顺序如下：</li><li>Visitors (访问器)：访问器最基本的思想是创建一个“访问器”对象，这个对象可以处理不同类型的节点函数,如下所示 <ul><li>在遍历节点的时候，当 enter (进入)到该节点，我们会调用访问器，然后会调用针对于这个节点的相关函数，同时这个节点和其父节点作为参数传入。</li><li>同时在exit（离开）的时候我们也希望能够调用访问器，当 enter 一个节点的时候，最外层节点就相当于一个分支，他是一个节点，这个分支的内部依然存在若干节点，就像上边遍历的那样</li><li>我们会按照深度优先的原则，依次遍历到这个分支的最内层，当达到最内层的时候，针对当前分支的访问就完成了，接着会依次exit（退出）节点，这个过程是由内向外的。</li></ul></li></ul><h3 id="code-generation-生成代码" tabindex="-1">Code Generation 生成代码 <a class="header-anchor" href="#code-generation-生成代码" aria-label="Permalink to &quot;Code Generation 生成代码&quot;">​</a></h3><p>将生成的新AST树再转回代码的过程</p><h2 id="广泛引用" tabindex="-1">广泛引用 <a class="header-anchor" href="#广泛引用" aria-label="Permalink to &quot;广泛引用&quot;">​</a></h2><ul><li><p>babel: 一个最常用的Javascript编译器，它能够转译 ECMAScript 2015+ 的代码，使它在旧的浏览器或者环境中也能够运行</p><ul><li><code>@babel/parser</code>可以把源码转换成AST</li><li><code>@babel/traverse</code>用于对 AST 的遍历，维护了整棵树的状态，并且负责替换、移除和添加节点</li><li><code>@babel/generate</code>可以把AST生成源码，同时生成sourcemap</li><li><code>@babel/types</code>用于 AST 节点的 Lodash 式工具库, 它包含了构造、验证以及变换 AST 节点的方法，对编写处理 AST 逻辑非常有用</li><li><code>@babel/core</code> Babel 的编译器，核心 API 都在这里面，比如常见的 transform、parse，并实现了插件功能</li></ul></li><li><p>eslint</p></li><li><p>代码压缩、混淆</p></li><li><p>按需加载</p></li><li><p>typescript类型校验</p></li></ul><h2 id="其它" tabindex="-1">其它 <a class="header-anchor" href="#其它" aria-label="Permalink to &quot;其它&quot;">​</a></h2><ul><li>AST基础：从零到一手撸一个功能完备的编译器</li><li>AST的应用：手写 按需加载插件 ，同事看了都说666</li><li>AST的应用：手写 Typescript 代码检测插件（fork-ts-checker-webpack-plugin），原来 TS语法检测如此简单</li><li>其他延伸：结合 AST 手写监控系统中的日志上传插件</li></ul>',21)]))}const T=a(o,[["render",n]]);export{h as __pageData,T as default};
