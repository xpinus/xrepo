import{a2 as o,t as i,aq as l,q as c}from"./chunks/framework.jAttmLhR.js";const k=JSON.parse('{"title":"web开发中会话跟踪的方法有哪些","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge-lib/js/场景应用/会话跟踪的方法.md","filePath":"knowledge-lib/js/场景应用/会话跟踪的方法.md"}'),s={name:"knowledge-lib/js/场景应用/会话跟踪的方法.md"};function t(a,e,n,r,d,p){return c(),i("div",null,e[0]||(e[0]=[l(`<h1 id="web开发中会话跟踪的方法有哪些" tabindex="-1">web开发中会话跟踪的方法有哪些 <a class="header-anchor" href="#web开发中会话跟踪的方法有哪些" aria-label="Permalink to &quot;web开发中会话跟踪的方法有哪些&quot;">​</a></h1><ul><li><code>canvas指纹</code>: <a href="https://zhuanlan.zhihu.com/p/436115112" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/436115112</a><ul><li>用户爱好分析</li><li>防刷</li></ul></li></ul><p><a href="https://www.bilibili.com/video/BV1RM411Q7Yn/?spm_id_from=333.788.videopod.sections&amp;vd_source=13577946ef3878abe2197cc65b72005c" target="_blank" rel="noreferrer">https://www.bilibili.com/video/BV1RM411Q7Yn/?spm_id_from=333.788.videopod.sections&amp;vd_source=13577946ef3878abe2197cc65b72005c</a></p><ul><li><p><code>cookie</code>：cookie由服务器生成,发送给浏览器,浏览器把cookie以键值对形式保存到某个目录下的文本文件内,下一次请求同一网站时会把该cookie发送给服务器.</p><ul><li>弊端： <ul><li>每个特定域名最多生成cookie数量有限制</li><li>没有加密，如果被人拦截会获取到所有信息</li></ul></li></ul></li><li><p><code>session</code>：服务器使用session把用户的信息临时保存在了服务器上,用户离开网站后session会被销毁.这种用户信息存储方式相对cookie来说更安全,可是session有一个缺陷: 如果服务器(集群)做了负载均衡,那么下一个操作请求被分配到了另一台服务器的时候session会丢失</p><ul><li>负载均衡：通常用于将工作负载分布到多个服务器来提高网站、应用、数据库或其他服务的性能和可靠性。</li></ul></li><li><p><code>token</code>: token类似于cookie,但是token是由服务器加了密的,是要进行身份验证的,存的信息还比cookie多，是一种思想，而不是具体的功能。</p><ul><li>用户登录校验，校验成功后就返回Token给客户端；客户端收到数据后保存在客户端；客户端每次请求携带Token到服务器端；服务器端采用filter过滤器校验token,校验成功则返回请求数据,校验失败则返回错误码</li><li>为什么使用token？ <ul><li>seesion：每次认证用户发起请求时,服务器需要去创建一个记录来存储信息.当越来越多的用户发请求时,内存的开销也会不断增加,服务器的压力越来越大,一直到服务器的极限.</li><li>CORS(跨域资源共享)：当我们需要让数据跨多台移动设备上使用时,跨域资源的共享会是一个让人头疼的问题.在使用Ajax抓取另一个域的资源,就可以会出现禁止请求的情况.</li><li>CSRF(跨站请求伪造)：用户在访问银行网站时,他们很容易受到跨站请求伪造的攻击,并且能够被利用其访问其他的网站.</li></ul></li></ul></li><li><p><code>url</code>重写</p><ul><li><p>当前浏览器把cookie禁用之后,浏览器在发请求的时候,就不会把cookie带到服务器端了(其中最重要的也包括JSESSIONID),因为禁用cookie之后浏览器拒绝一切站点向浏览器写入cookie的(注意再禁用之前是否已经有一些已经存在的cookie了),这样的话,多个请求就不能在服务器端拿到同一个session对象了(因为发送请求的时候没有把JSESSIONID的值传给服务器)。</p><pre><code>把JSESSIONID从客户端传给服务器,有俩种方式:
1.JSESSIONID保存在cookie文件中,浏览器发送请求的时候把这个cookie文件中的数据带给服务器(cookie).
2.通过传参的方式,把JSESSIONID的值通过要访问的URL传给服务器.(URL重写)
</code></pre></li></ul></li><li><p><code>ip</code>地址</p></li><li><p>隐藏表单：在所有页面中,利用js 将用户ID设置在隐藏表单中,每次请求服务器的时候,将用户id上传,如果有一个表单没有上传,那么服务器就找不到该用户了</p></li></ul>`,4)]))}const _=o(s,[["render",t]]);export{k as __pageData,_ as default};
