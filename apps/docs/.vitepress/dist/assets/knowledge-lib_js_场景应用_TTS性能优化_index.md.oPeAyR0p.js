import{a2 as i,t as a,aq as l,q as n}from"./chunks/framework.jAttmLhR.js";const t="/assets/tts.C5DSPTDm.png",c=JSON.parse('{"title":"TTS性能优化技术","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge-lib/js/场景应用/TTS性能优化/index.md","filePath":"knowledge-lib/js/场景应用/TTS性能优化/index.md"}'),e={name:"knowledge-lib/js/场景应用/TTS性能优化/index.md"};function p(h,s,k,r,o,d){return n(),a("div",null,s[0]||(s[0]=[l('<h1 id="tts性能优化技术" tabindex="-1">TTS性能优化技术 <a class="header-anchor" href="#tts性能优化技术" aria-label="Permalink to &quot;TTS性能优化技术&quot;">​</a></h1><blockquote><p>TTS，英语全称 Text-to-Speech，中文就是“文字转语音”</p></blockquote><p>TTS的实现直接使用 WebAPI 就能够实现。但存在一些问题：</p><ul><li>不同的操作系统转换出来的音效不同</li><li>无法定制化语音效果</li><li>有一定的兼容性问题</li></ul><p>第三方平台 <img src="'+t+`" alt=""> 存在一些待解决的问题：</p><ul><li>大文本的转换非常耗时</li><li>大文本转换出来的音频也很大，也存在传输耗时的问题</li><li>如何给文本添加情绪</li></ul><p><strong>解决思路</strong></p><ul><li>将大文本进行分割，拆解成小文本。</li><li>添加情绪需要用到一些自然语言处理库</li><li>对转换过了的文本进行缓存</li></ul><ol><li>文本断句：文本断句的时候需要考虑到文本切割的一个粒度, 以标点符号来断句</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> splitTextByPunctuation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 使用正则表达式匹配句子结束的标点符号</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> text.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">match</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">。！？]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[。！？]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">g</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 示例文本</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> longText</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;这是第一句话。这里是第二句话，包含更多的内容。还有一些问句吗？当然有！这是最后一句。&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用标点符号进行断句</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sentences</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> splitTextByPunctuation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(longText);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sentences);</span></span></code></pre></div><ol start="2"><li>情绪标记, 这里需要借助一些自然语言处理库, 如果需要，可能需要额外的服务进行处理</li><li>并发的控制，因为大文本被拆成了小文本，文本内容减少了，但是文本的量增多了。 <ol><li>限制并发的数量</li><li>使用队列来管理请求</li><li>动态的去调整并发的数量</li><li>请求的取消</li><li>转换base64：前端服务器拿到 bytes 数据后，可以进行一层转换，将其转换为 base64 格式的数据，这样客户端的页面上使用的时候就会更加方便，可以给生成的 audio 元素的 src 属性直接赋值这个 base64</li><li>进行缓存 <ol><li>缓存在客户端的好处在于获取缓存的速度很快，可以采用 localstorage 来存，值存对应的 base64 数据，键则是对应的文本内容。不过这里有个细节的点要考虑，就是键如果直接用文本的话，可能一句话过长，导致键超出 localstorage 的长度限制，所以需要做一层 MD5 处理。本来都打算这么做了，后来我想了一下，客户端的缓存只能存当前用户转换过的文本，但是一般来讲，用户看完某篇知识文档后，转而就会去看下一篇，不太会一篇文档翻来复去听个十来遍，除非是一篇超高质量、需要反复玩味的文档。</li></ol></li></ol></li></ol><blockquote><p>我看到你的项目亮点里面写的是“优化 TTS 服务性能问题”，你能详细说一下这是啥么？然后讲一下有什么样的性能问题么？并且你这边具体是如何进行优化的？</p></blockquote><p>将TTS相关的逻辑操作封装成一个useTTS</p><ul><li>传入参数为要使用的tts服务, 方便开发时用浏览器的api，灰度或线上再用后端接口</li><li>返回一个speaker，接口模式， <ul><li>实现speak\\pause\\resume\\cancel等功能</li><li>注册回调函数，onend: 没读完一句话触发</li></ul></li></ul>`,14)]))}const E=i(e,[["render",p]]);export{c as __pageData,E as default};
