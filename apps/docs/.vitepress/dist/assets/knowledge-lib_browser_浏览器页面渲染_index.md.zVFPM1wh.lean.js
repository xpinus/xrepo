import{a3 as o,t as l,ao as t,q as a}from"./chunks/framework.Dt9YBBJv.js";const i="/assets/render.CLG76Qq5.png",g=JSON.parse('{"title":"页面渲染","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge-lib/browser/浏览器页面渲染/index.md","filePath":"knowledge-lib/browser/浏览器页面渲染/index.md"}'),r={name:"knowledge-lib/browser/浏览器页面渲染/index.md"};function d(c,e,n,s,u,p){return a(),l("div",null,e[0]||(e[0]=[t('<h1 id="页面渲染" tabindex="-1">页面渲染 <a class="header-anchor" href="#页面渲染" aria-label="Permalink to &quot;页面渲染&quot;">​</a></h1><blockquote><p>一次请求会产生哪些缓存？ <code>dns</code>缓存，<code>cdn</code>缓存，浏览器缓存，服务器缓存</p></blockquote><h2 id="从浏览器地址栏输入url到显示页面的步骤" tabindex="-1">从浏览器地址栏输入url到显示页面的步骤 <a class="header-anchor" href="#从浏览器地址栏输入url到显示页面的步骤" aria-label="Permalink to &quot;从浏览器地址栏输入url到显示页面的步骤&quot;">​</a></h2><p>浏览器自动补全协议端口，根据url查找本地缓存</p><ol><li><a href="/knowledge-lib/browser/DNS/">DNS解析</a>获取目标服务器IP地址</li><li>发起HTTP请求 <ul><li>打开一个socket与目标IP地址端口，三次握手，建立TCP连接</li><li>https还会进行TLS握手，建立加密通道</li><li>浏览器设置请求头、协议、cookie等发出get请求</li><li>服务器接收到请求进行解析，返回结果。</li></ul></li><li>服务端处理返回HTTP响应报文，浏览器接收响应 <ul><li>浏览器根据协议版本，以及Connection字段的约定，决定关闭TCP或保留重用，</li><li>浏览器根据响应码决定对响应的处理方式</li><li>如果响应头是<code>text/html</code>，则对其进行html解析，解码数据（如gzip压缩）</li><li>浏览器根据响应头的其它内容完成缓存、cookie的设置</li></ul></li><li>浏览器解析渲染页面</li></ol><ul><li>当浏览器的<strong>网络线程</strong>收到HTML文档后，会产生一个<strong>渲染任务</strong>，并将其传递给<strong>渲染主线程的消息队列</strong>。</li><li>在<strong>事件循环机制</strong>的作用下，渲染主线程取出消息队列中的渲染任务，开启<strong>渲染流程</strong></li><li>渲染流程分为多个阶段：<code>HTML解析</code>、<code>样式计算</code>、<code>布局</code>、<code>分层</code>、<code>绘制</code>、<code>分块</code>、<code>光栅化</code>、<code>绘画</code>，每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入，形成一个严密的渲染流水线。</li></ul><p><img src="'+i+'" alt="渲染流程"></p><h3 id="html解析流程" tabindex="-1">HTML解析流程 <a class="header-anchor" href="#html解析流程" aria-label="Permalink to &quot;HTML解析流程&quot;">​</a></h3><ul><li>解析HTML文档，构建<code>DOM树</code><ul><li>字节数据 -- 字符串 -- 字符串标记 -- 分析出node节点 -- 构建dom树</li><li>预解析线程：为提高效率，率先下载外部css和外部js</li></ul></li><li>遇到link，并行下载，解析css，构建<code>CSSOM树</code><ul><li>不会阻塞DOM解析，但会阻塞script加载，依照HTML5标准，javascript脚本执行前，出现在当前script之前的link必须完全载入</li></ul></li><li>遇到script，会阻塞DOM解析，执行js脚本 <ul><li>原因：js中可能会修改DOM, 如果先解析后加载的话，DOM 树还得重新解析</li><li>异步加载script的属性： <ul><li><code>defer</code>：异步加载，等 DOM 解析完之后再运行，在 <code>DOMContentloaed</code> 之前，因此其还是会阻塞DOM解析</li><li><code>async</code>: 异步加载，但等该资源下载完成之后立刻运行，运行时机不定，可能会可能不会阻塞DOM解析</li><li><a href="https://juejin.cn/post/6844903745730396174#heading-1" target="_blank" rel="noreferrer">浏览器是如何解析html的？</a></li></ul></li></ul></li></ul><h3 id="样式计算" tabindex="-1">样式计算 <a class="header-anchor" href="#样式计算" aria-label="Permalink to &quot;样式计算&quot;">​</a></h3><p>主线程会遍历DOM树，计算每个节点的最终样式<code>Computed Style</code>。在这一过程中很多预设值会变成绝对值，比如<code>red</code>变成<code>rgb(255,0,0)</code>. <strong>这一步结束后会得到一棵带有样式的DOM树</strong></p><h3 id="布局layout" tabindex="-1">布局Layout <a class="header-anchor" href="#布局layout" aria-label="Permalink to &quot;布局Layout&quot;">​</a></h3><p>布局阶段会遍历DOM树，计算每个节点的<code>几何信息</code>，例如节点的宽高、位置</p><h3 id="分层layer" tabindex="-1">分层Layer <a class="header-anchor" href="#分层layer" aria-label="Permalink to &quot;分层Layer&quot;">​</a></h3><p>主线程会使用复杂的策略对整个布局树进行分层，意义在于当某个层改变后，仅对该层进行处理，提升效率。</p><p>滚动条、堆叠上下文、transform、opacity等或多或少会影响分层结果，也可以通过will-change更大程度上影响分层结果</p><h3 id="绘制paint" tabindex="-1">绘制paint <a class="header-anchor" href="#绘制paint" aria-label="Permalink to &quot;绘制paint&quot;">​</a></h3><p>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何绘制</p><p><strong>完成后</strong>，主线程将每个图层的绘制信息提交给<code>合成线程</code>，剩余工作将有合成线程完成</p><h3 id="合成tilling" tabindex="-1">合成tilling <a class="header-anchor" href="#合成tilling" aria-label="Permalink to &quot;合成tilling&quot;">​</a></h3><p>合成线程对图层进行分块，将其划分为更多的小区域。分块的工作是多线程同时进行的</p><h3 id="光栅化rast" tabindex="-1">光栅化rast <a class="header-anchor" href="#光栅化rast" aria-label="Permalink to &quot;光栅化rast&quot;">​</a></h3><p>合成线程会将块信息交给<code>GPU进程</code>，GPU会开启多个线程快速完成光栅化，并优先处理靠近视口的区域</p><h3 id="画-draw" tabindex="-1">画 draw <a class="header-anchor" href="#画-draw" aria-label="Permalink to &quot;画 draw&quot;">​</a></h3><ul><li><code>合成线程</code>拿到光栅化结果的位图后，生成一个个<strong>指引quad</strong>信息。</li><li>指引会标识出每个位图应该画到屏幕哪个位置，以及考虑到旋转、缩放等变形 <ul><li><strong>变形发生在合成线程，与渲染主线程无关，这就是transform效率高的本质</strong></li></ul></li><li>合成线程将指引（渲染帧）交给<strong>GPU</strong>，最终完成屏幕成像</li></ul><h2 id="面试题" tabindex="-1">面试题 <a class="header-anchor" href="#面试题" aria-label="Permalink to &quot;面试题&quot;">​</a></h2><p><strong>1. 什么是回流 reflow 和 重绘 repaint ?</strong></p><blockquote><p>reflow的本质是浏览器重新计算layout树</p></blockquote><ul><li>当进行了会影响布局树的操作后（如：尺寸、位置、隐藏/状态状态发生改变时），产生重绘回流，重新计算布局树</li><li><strong>注意</strong>：JS 获取 Layout 属性值（如：<code>offsetLeft</code>、<code>scrollTop</code>、<code>getComputedStyle</code>等）也会引起回流。因为浏览器需要通过回流计算最新值，而修改则是异步的</li><li>回流必将引起重绘，而重绘不一定会引起回流</li></ul><blockquote><p>repaint的本质是重新根据分层信息计算绘制指令</p></blockquote><ul><li>当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘</li></ul><blockquote><p>如何避免？</p></blockquote><ul><li>需要要对元素进行复杂的操作时，可以先隐藏(<code>display:&quot;none&quot;</code>)，操作完成后再显示</li><li>需要创建多个<code>DOM</code>节点时，使用<code>DocumentFragment</code>创建完后一次性的加入<code>document</code></li><li>缓存<code>Layout</code>属性值，如：<code>var left = elem.offsetLeft;</code> 这样，多次使用 <code>left</code> 只产生一次回流</li><li>批量修改元素样式：<code>elem.className</code> 和 <code>elem.style.cssText</code> 代替 <code>elem.style.xxx</code></li><li>使用fragment，批量操作</li><li>在某些地方使用<code>el.style.top</code>直接从dom上读取属性而不是读取几何信息</li><li>让元素脱离文档流，使用<code>position:absolute</code>等，减少回流</li></ul><p><strong>2. 为什么transform效率高 ?</strong></p><p><strong>transform</strong>只影响渲染流程的最后一个<code>draw</code>阶段，不会影响<code>layout布局</code>或<code>paint绘制指令</code></p><p>而且由于draw阶段位于<code>合成线程</code>，所以transform的变化和渲染主线程互不影响</p><p><strong>3. window.onload和DOMContentLoaded有什么区别？</strong></p><p>DOMContentLoaded 事件在 DOM 树构建完成时触发，但不需要等待样式表、图片和子框架等资源加载完成。</p><p>window.onload 事件则在页面上所有的资源（包括 DOM、样式表、脚本、图片、Flash 等）都加载完成后触发。</p>',39)]))}const m=o(r,[["render",d]]);export{g as __pageData,m as default};
