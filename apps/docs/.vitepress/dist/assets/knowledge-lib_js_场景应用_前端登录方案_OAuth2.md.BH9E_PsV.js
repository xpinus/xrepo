import{a2 as i,t as a,ao as t,q as e}from"./chunks/framework.tQiMsDJj.js";const n="/assets/OAuth2.DP9vjvon.png",E=JSON.parse('{"title":"OAuth2.0","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge-lib/js/场景应用/前端登录方案/OAuth2.md","filePath":"knowledge-lib/js/场景应用/前端登录方案/OAuth2.md"}'),l={name:"knowledge-lib/js/场景应用/前端登录方案/OAuth2.md"};function p(h,s,k,o,r,d){return e(),a("div",null,s[0]||(s[0]=[t('<h1 id="oauth2-0" tabindex="-1">OAuth2.0 <a class="header-anchor" href="#oauth2-0" aria-label="Permalink to &quot;OAuth2.0&quot;">​</a></h1><h2 id="认识oauth2-0" tabindex="-1">认识OAuth2.0 <a class="header-anchor" href="#认识oauth2-0" aria-label="Permalink to &quot;认识OAuth2.0&quot;">​</a></h2><blockquote><p><a href="http://en.wikipedia.org/wiki/OAuth" target="_blank" rel="noreferrer">OAuth</a>是一个关于授权（authorization）的开放网络标准协议，简单理解就是一种授权机制。</p></blockquote><h3 id="授权机制设计" tabindex="-1">授权机制设计 <a class="header-anchor" href="#授权机制设计" aria-label="Permalink to &quot;授权机制设计&quot;">​</a></h3><p><img src="'+n+`" alt=""></p><blockquote><p><strong>OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用</strong> 令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这也是 OAuth 2.0 的优点。</p></blockquote><p>令牌的特点</p><ul><li>短期的，到期会自动失效，用户自己无法修改。</li><li>可以被数据所有者撤销，会立即失效。</li><li>有权限范围（scope），对于网络服务来说，只读令牌就比读写令牌更安全。</li></ul><h3 id="获取令牌四种实现方式" tabindex="-1">获取令牌四种实现方式 <a class="header-anchor" href="#获取令牌四种实现方式" aria-label="Permalink to &quot;获取令牌四种实现方式&quot;">​</a></h3><ul><li>授权码（authorization-code）</li><li>隐藏式（implicit）</li><li>密码式（password）：</li><li>客户端凭证（client credentials）</li></ul><blockquote><p>不管哪一种授权方式，第三方应用申请令牌之前，<strong>都必须先到系统备案</strong>，说明自己的身份，然后会拿到两个身份识别码：<strong>客户端 ID（client ID）和客户端密钥（client secret）</strong>。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的；</p></blockquote><h4 id="授权码" tabindex="-1">授权码 <a class="header-anchor" href="#授权码" aria-label="Permalink to &quot;授权码&quot;">​</a></h4><p><strong>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌（适合前后端分离，最常用的方式）。</strong></p><blockquote><p>这种方式是最常用的流程，安全性也最高，它适用于有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p></blockquote><ol><li><p><strong>A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">https</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//b.com/oauth/authorize?</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  response_type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">code</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  client_id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CLIENT_ID</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  redirect_uri</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CALLBACK_URL</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  scope</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">read</span></span></code></pre></div><ul><li>response_type=code <em>code参数表示要求返回授权码</em></li><li>client_id=CLIENT_ID <em>参数让B知道是谁在请求数据</em></li><li>redirect_uri = CALLBACK_URL <em>当B网站处理完成链接请求后的跳转地址</em></li><li>scope=read <em>表示要授权的范围，read代表对授权资源进行只读操作</em></li></ul></li><li><p><strong>跳转成功，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回<code>redirect_uri</code>参数指定的网址。跳转时，会传回一个授权码</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">https</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//a.com/callback?code=AUTHORIZATION_CODE     // code 代表授权码</span></span></code></pre></div></li><li><p><strong>A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。</strong></p></li></ol><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">https://b.com/oauth/token?</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> client_id=CLIENT_ID&amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> client_secret=CLIENT_SECRET&amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> grant_type=authorization_code&amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> code=AUTHORIZATION_CODE&amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> redirect_uri=CALLBACK_URL</span></span></code></pre></div><ul><li>client_id <em>确认A的身份</em></li><li>client_secret <em>确认A的身份</em></li><li>grant_type <em>表示使用授权的方式获取授权码</em></li><li>code <em>第二步中获取到的code值</em></li><li>redirect_uri <em>令牌颁发后的回调地址</em></li></ul><ol start="4"><li><strong>B 网站收到请求以后，就会颁发令牌。具体做法是向<code>redirect_uri</code>指定的网址，发送一段 JSON 数据。</strong></li></ol><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{    </span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;access_token&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ACCESS_TOKEN&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;token_type&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;bearer&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;expires_in&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2592000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;refresh_token&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;REFRESH_TOKEN&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;scope&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;read&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;uid&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100101</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;info&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:{</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="隐藏式" tabindex="-1">隐藏式 <a class="header-anchor" href="#隐藏式" aria-label="Permalink to &quot;隐藏式&quot;">​</a></h4><blockquote><p>适用于纯前端的WEB应用，必须将令牌储存在前端。允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）&quot;隐藏式&quot;（implicit）。<strong>由于前端直接获取token，安全性较低，一般适用于比较信任的网站，并且令牌的有效期，也相对较短，一般是界面关闭及失效</strong></p></blockquote><ol><li><p><strong>A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用</strong></p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">https://b.com/oauth/authorize?</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  response_type=token&amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  client_id=CLIENT_ID&amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  redirect_uri=CALLBACK_URL&amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  scope=read</span></span></code></pre></div><blockquote><p>response_type=token 表示直接返回令牌</p></blockquote></li><li><p><strong>用户跳转到 B 网站，登录后同意给予 A 网站授权。B 网站就会跳回<code>redirect_uri</code>参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。</strong></p></li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">https</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//a.com/callback#token=ACCESS_TOKEN</span></span></code></pre></div><blockquote><p>token参数为令牌，<strong>令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在&quot;中间人攻击&quot;的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。</strong></p></blockquote><h4 id="密码式" tabindex="-1">密码式 <a class="header-anchor" href="#密码式" aria-label="Permalink to &quot;密码式&quot;">​</a></h4><blockquote><p>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为&quot;密码式&quot;（password）。</p></blockquote><ol><li>第一步，A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">https</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//oauth.b.com/token?</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> grant_type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">password</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> username</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">USERNAME</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> password</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PASSWORD</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> client_id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CLIENT_ID</span></span></code></pre></div><ul><li>grant_type = password <em>授权方式为密码的形式进行授权</em></li><li>username &amp;&amp; userpassword <em>B网站的登录用户名及密码</em></li><li>client_id <em>用户申请令牌的身份标识</em></li></ul><ol start="2"><li>B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。</li></ol><blockquote><p>这种方式需要用户给出自己的用户名/密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应</p></blockquote><h4 id="凭证式" tabindex="-1">凭证式 <a class="header-anchor" href="#凭证式" aria-label="Permalink to &quot;凭证式&quot;">​</a></h4><blockquote><p>凭证式和密码式很相似，主要适用于那些没有前端的命令行应用，可以用最简单的方式获取令牌，在请求响应的 <code>JSON</code> 结果中返回 <code>token</code>。</p></blockquote><ol><li><strong>第一步，A 应用在命令行向 B 发出请求。</strong></li></ol><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">https://oauth.b.com/token?</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  grant_type=client_credentials&amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  client_id=CLIENT_ID&amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  client_secret=CLIENT_SECRET</span></span></code></pre></div><p><code>grant_type</code> 为 <code>client_credentials</code> 表示凭证式授权，<code>client_id</code> 和 <code>client_secret</code> 用来识别身份。</p><ol start="2"><li>B 网站验证通过以后，直接返回令牌。</li></ol><h3 id="令牌的使用-更新" tabindex="-1">令牌的使用/更新 <a class="header-anchor" href="#令牌的使用-更新" aria-label="Permalink to &quot;令牌的使用/更新&quot;">​</a></h3><h5 id="使用" tabindex="-1">使用 <a class="header-anchor" href="#使用" aria-label="Permalink to &quot;使用&quot;">​</a></h5><blockquote><p>A 网站拿到令牌以后，就可以向 B 网站的 API 请求数据了。使用方法为在请求头中将 <code>token</code> 放在 <code>http</code> 请求头部的一个<code>Authorization</code>字段里。</p></blockquote><h5 id="更新" tabindex="-1">更新 <a class="header-anchor" href="#更新" aria-label="Permalink to &quot;更新&quot;">​</a></h5><blockquote><p><code>token</code>是有时效性的，一旦过期就需要重新获取，令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌</p></blockquote><h5 id="实现方法" tabindex="-1">实现方法 <a class="header-anchor" href="#实现方法" aria-label="Permalink to &quot;实现方法&quot;">​</a></h5><blockquote><p>具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。</p></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">https</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//b.com/oauth/token?</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  grant_type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">refresh_token</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  client_id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CLIENT_ID</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  client_secret</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CLIENT_SECRET</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  refresh_token</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">REFRESH_TOKEN</span></span></code></pre></div><p><code>grant_type</code>参数为<code>refresh_token</code>表示要求更新令牌；</p><p><code>client_id</code>参数和<code>client_secret</code>参数用于确认身份；</p><p><code>refresh_token</code>参数就是用于更新令牌的令牌。</p><p>B 网站验证通过以后，就会颁发新的令牌</p>`,49)]))}const g=i(l,[["render",p]]);export{E as __pageData,g as default};
