import{a3 as s,t as l,ao as e,q as t}from"./chunks/framework.Dt9YBBJv.js";const k=JSON.parse('{"title":"DOM","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge-lib/browser/DOM.md","filePath":"knowledge-lib/browser/DOM.md"}'),a={name:"knowledge-lib/browser/DOM.md"};function n(o,i,h,p,d,r){return t(),l("div",null,i[0]||(i[0]=[e(`<h1 id="dom" tabindex="-1">DOM <a class="header-anchor" href="#dom" aria-label="Permalink to &quot;DOM&quot;">​</a></h1><blockquote><p>Document Object Model 文档对象模型</p></blockquote><ul><li>它提供了<strong>对文档的结构化</strong>的表述，任何HTML或XML文档都可以用DOM表示为一个由节点构成的层级结构</li><li><strong>提供API</strong>用于修改文档，创建节点、查询节点、更新节点、添加节点、删除节点、更改样式、绑定事件</li></ul><h2 id="api" tabindex="-1">API <a class="header-anchor" href="#api" aria-label="Permalink to &quot;API&quot;">​</a></h2><p><strong>创建新节点</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createDocumentFragment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//创建一个DOM片段</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//创建一个具体的元素</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createTextNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//创建一个文本节点</span></span></code></pre></div><p><strong>添加、移除、替换、插入</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//添加</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//移除</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">replaceChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//替换</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insertBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//插入</span></span></code></pre></div><p><strong>查找</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementsByTagName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//通过标签名称</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementsByName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//通过元素的Name属性的值</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//通过元素Id，唯一性</span></span></code></pre></div><h2 id="面试题" tabindex="-1">面试题 <a class="header-anchor" href="#面试题" aria-label="Permalink to &quot;面试题&quot;">​</a></h2><blockquote><p>事件冒泡和事件捕捉有什么区别</p></blockquote><ul><li><strong>捕获阶段</strong>：从window对象传导到目标节点（上层传到底层）称为“捕获阶段”（capture phase）</li><li><strong>目标阶段</strong>：在目标节点上触发，称为“目标阶段”</li><li><strong>冒泡阶段</strong>：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层； <ul><li><code>event.target</code>判断具体有哪个子节点触发</li><li><code>currentTarget</code>是指其事件处理程序当前正在处理事件的那个元素</li></ul></li></ul><p>事件冒泡 在 addEventListener 中的第三属性设置为 false（<strong>默认</strong>）</p><p>事件捕捉 在 addEventListener 中的第三属性设置为 true</p><p><strong>冒泡事件很多，记住其他不支持冒泡的事件就好了</strong></p><ul><li>focus</li><li>blur</li><li>mouseenter</li><li>mouseleave</li><li>load</li><li>unload</li><li>resize</li></ul><blockquote><p>什么是事件代理</p></blockquote><p>事件代理（<code>Event Delegation</code>），又称之为事件委托。是 <code>JavaScript</code> 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是 DOM 元素的事件冒泡。使用事件代理的好处是可以提高性能</p><ul><li><strong>原理：事件冒泡</strong></li><li>优点： <ul><li>可以大量节省内存占用，减少事件注册，比如在<code>ul</code>上代理所有<code>li</code>的<code>click</code>事件就非常棒</li><li>可以实现当新增子对象时无需再次对其绑定</li></ul></li></ul><blockquote><p>offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别</p></blockquote><ul><li><code>offsetWidth/offsetHeight</code>偏移量： <ul><li>返回值包含<strong>content + padding + border</strong>，效果与e.getBoundingClientRect()相同</li></ul></li><li><code>clientWidth/clientHeight</code>客户区大小： <ul><li>返回值只包含<strong>content + padding</strong>，如果有滚动条，也<strong>不包含滚动条</strong></li></ul></li><li><code>scrollWidth/scrollHeight</code>包含滚动内容的元素的大小： <ul><li>返回值包含<strong>content + padding + 溢出内容的尺寸</strong></li></ul></li></ul><h2 id="htmlcollection-和-nodelist-有什么区别" tabindex="-1">HTMLCollection 和 NodeList 有什么区别 <a class="header-anchor" href="#htmlcollection-和-nodelist-有什么区别" aria-label="Permalink to &quot;HTMLCollection 和 NodeList 有什么区别&quot;">​</a></h2><ol><li>实时性，HTMLCollection是实时的，当dom变化会自动更新；NodeList大多数情况下是静态的</li><li>包含的节点类型：HTMLCollection仅包含元素节点，NodeList可以包含任意类型的节点</li><li>forEach: HTMLCollection没有</li><li>访问方式：NodeList只能通过索引访问，HTMLCollection 可以通过索引、元素 id 或 name 属性访问</li></ol>`,24)]))}const g=s(a,[["render",n]]);export{k as __pageData,g as default};
