import{a2 as o,t as i,aq as n,K as t,y as e,a0 as r,ab as s,q as d}from"./chunks/framework.jAttmLhR.js";const j=JSON.parse('{"title":"深浅拷贝","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge-lib/js/算法/经典手写/深浅拷贝/index.md","filePath":"knowledge-lib/js/算法/经典手写/深浅拷贝/index.md"}'),c={name:"knowledge-lib/js/算法/经典手写/深浅拷贝/index.md"};function u(h,l,p,m,b,f){const a=s("run-script");return d(),i("div",null,[l[0]||(l[0]=n('<h1 id="深浅拷贝" tabindex="-1">深浅拷贝 <a class="header-anchor" href="#深浅拷贝" aria-label="Permalink to &quot;深浅拷贝&quot;">​</a></h1><h2 id="浅拷贝" tabindex="-1">浅拷贝 <a class="header-anchor" href="#浅拷贝" aria-label="Permalink to &quot;浅拷贝&quot;">​</a></h2><ul><li>展开运算符<code>...</code></li><li><code>Object.assign</code></li></ul><h2 id="深拷贝" tabindex="-1">深拷贝 <a class="header-anchor" href="#深拷贝" aria-label="Permalink to &quot;深拷贝&quot;">​</a></h2><ul><li>可以通过 <code>JSON.parse(JSON.stringify(object))</code> 来解决 <ul><li>会忽略 <code>undefined</code>和函数</li><li>不能解决循环引用的对象</li><li>将Date对象转换为字符串</li></ul></li><li>第三方库lodash, 递归拷贝</li></ul>',5)),t(a,{codePath:"knowledge-lib/js/算法/经典手写/深浅拷贝/deepClone.js"}),l[1]||(l[1]=e("ul",null,[e("li",null,[r("structuredClone() API 结构化克隆算法 "),e("ul",null,[e("li",null,"core-js 已经支持 structuredClone 的 polyfill"),e("li",null,"是浏览器提供的原生API，内部实现已经处理了许多复杂的细节和边缘情况，如循环引用、嵌套对象等，性能更好"),e("li",null,"可以用于跨线程或跨工作线程的数据传输"),e("li",null,"不支持拷贝某些复杂类型，如 Function、Dom节点、及对象上的一些特殊参数getter/setter/原型链等")])])],-1)),t(a,{codePath:"knowledge-lib/js/算法/经典手写/深浅拷贝/structure.js"})])}const k=o(c,[["render",u]]);export{j as __pageData,k as default};
