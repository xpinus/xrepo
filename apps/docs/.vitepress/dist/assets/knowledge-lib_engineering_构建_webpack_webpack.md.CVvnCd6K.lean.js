import{a3 as i,t as a,ao as e,q as n}from"./chunks/framework.Dt9YBBJv.js";const l="/assets/webpack.BGGMf3Uy.png",p="/assets/chunk.BNP8WTX6.png",t="/assets/webpack-compiler.CKIPclcz.png",h="/assets/perform.B0aU1-4N.png",b=JSON.parse('{"title":"Webpack","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge-lib/engineering/构建/webpack/webpack.md","filePath":"knowledge-lib/engineering/构建/webpack/webpack.md"}'),k={name:"knowledge-lib/engineering/构建/webpack/webpack.md"};function c(r,s,o,d,g,E){return n(),a("div",null,s[0]||(s[0]=[e('<h1 id="webpack" tabindex="-1">Webpack <a class="header-anchor" href="#webpack" aria-label="Permalink to &quot;Webpack&quot;">​</a></h1><p>webpack是基于模块化的打包（构建）工具，它把一切视为模块.它通过一个开发时态的入口模块为起点，分析出所有的依赖关系，然后经过一系列的过程（压缩、合并），最终生成运行时态的文件。</p><p><img src="'+l+'" alt=""></p><h2 id="编译过程" tabindex="-1">编译过程 <a class="header-anchor" href="#编译过程" aria-label="Permalink to &quot;编译过程&quot;">​</a></h2><blockquote><p>大致分为三个步骤：初始化、编译、输出</p></blockquote><h3 id="初始化" tabindex="-1">初始化 <a class="header-anchor" href="#初始化" aria-label="Permalink to &quot;初始化&quot;">​</a></h3><p>此阶段，webpack会将CLI参数、配置文件、默认配置进行融合，形成一个最终的配置对象。</p><p>对配置的处理过程是依托一个第三方库yargs完成的</p><h3 id="编译" tabindex="-1">编译 <a class="header-anchor" href="#编译" aria-label="Permalink to &quot;编译&quot;">​</a></h3><p><strong>1. 创建chunk</strong></p><p>chunk是webpack在内部构建过程中的一个概念，译为块，它表示通过某个入口找到的所有依赖的统称。</p><p>根据入口模块（默认为./src/index.js）创建一个chunk（main chunk）</p><p>每个chunk都有至少两个属性：</p><ul><li>name：默认为main</li><li>id：唯一编号，开发环境和name相同，生产环境是一个数字，从0开始</li></ul><p><strong>2. 构建所有依赖模块</strong></p><p>从入口文件开始递归处理所有模块</p><p><img src="'+p+'" alt=""></p><blockquote><p>AST在线测试工具：<a href="https://astexplorer.net/" target="_blank" rel="noreferrer">https://astexplorer.net/</a></p></blockquote><p><strong>3. 产生chunk assets</strong></p><p>在第二步完成后，chunk（除了main可能还有其他chunk）中会产生一个模块列表，列表中包含了模块id和模块转换后的代码</p><p>接下来，webpack会根据配置为chunk生成一个资源列表，即chunk assets，资源列表可以理解为是生成到最终文件的文件名和文件内容</p><p><strong>4. 合并chunk assets</strong></p><p>将多个chunk的assets合并到一起，并产生一个总的hash</p><h3 id="输出" tabindex="-1">输出 <a class="header-anchor" href="#输出" aria-label="Permalink to &quot;输出&quot;">​</a></h3><p>此步骤非常简单，webpack将利用node中的fs模块（文件处理模块），根据编译产生的总的assets，生成相应的文件。</p><p><img src="'+t+`" alt=""></p><p><strong>涉及术语</strong></p><ul><li>module：模块，分割的代码单元，webpack中的模块可以是任何内容的文件，不仅限于JS</li><li>chunk：webpack内部构建模块的块，一个chunk中包含多个模块，这些模块是从入口模块通过依赖分析得来的</li><li>bundle：chunk构建好模块后会生成chunk的资源清单，清单中的每一项就是一个bundle，可以认为bundle就是最终生成的文件</li><li>hash：最终的资源清单所有内容联合生成的hash值</li><li>chunkhash：chunk生成的资源清单内容联合生成的hash值</li><li>chunkname：chunk的名称，如果没有配置则使用main</li><li>id：通常指chunk的唯一编号，如果在开发环境下构建，和chunkname相同；如果是生产环境下构建，则使用一个从0开始的数字进行编号</li><li>入口：入口真正配置的是chunk，入口通过entry进行配置 <ul><li>name：chunkname</li><li>hash: 总的资源hash，通常用于解决缓存问题</li><li>chunkhash: 使用chunkhash</li><li>id: 使用chunkid，不推荐</li></ul></li><li>出口：通过output进行配置</li></ul><h3 id="区分环境" tabindex="-1">区分环境 <a class="header-anchor" href="#区分环境" aria-label="Permalink to &quot;区分环境&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// npx webpack --env abc # env: &quot;abc&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// npx webpack --env.abc # env: {abc:true}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// npx webpack --env.abc=1  # env： {abc:1}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// npx webpack --env.abc=1 --env.bcd=2 # env: {abc:1, bcd:2}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// webpack允许配置不仅可以是一个对象，还可以是一个函数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> env</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //配置内容</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>面试题：关于 webpack 的打包流程，你有了解过么？</p></blockquote><p>webpack 的打包流程大致可以分为以下几个步骤：</p><ol><li>初始化：webpack 通过配置文件和 Shell 参数，初始化参数，确定入口文件、输出路径、加载器、插件等信息。接下来读取配置文件，并合并默认配置、CLI 参数等，生成最终的配置对象。</li><li>编译：从入口文件开始，递归解析模块依赖，找到所有需要打包的模块。之后使用 loader 对每个模块进行转换，转换成浏览器能够识别的 JS 代码。</li><li>构建模块依赖图：webpack 会为每个模块创建一个模块对象，并根据模块的依赖关系，生成一个模块依赖图（Dependency Graph）。</li><li>生成代码块（chunk）：根据入口和依赖图，将所有模块分组，生成一个个包含多个模块的代码块（chunk），这些 chunk 会根据配置生成不同的输出文件。</li><li>输出：将生成的代码块输出到指定的文件夹，并根据配置生成对应的静态资源文件。</li><li>插件处理：在整个构建过程中，webpack 会在特定的生命周期钩子上执行插件，插件可以对打包的各个阶段进行干预和处理。</li></ol><h2 id="常用扩展" tabindex="-1">常用扩展 <a class="header-anchor" href="#常用扩展" aria-label="Permalink to &quot;常用扩展&quot;">​</a></h2><h3 id="通用" tabindex="-1">通用 <a class="header-anchor" href="#通用" aria-label="Permalink to &quot;通用&quot;">​</a></h3><h3 id="webpack4" tabindex="-1">webpack4 <a class="header-anchor" href="#webpack4" aria-label="Permalink to &quot;webpack4&quot;">​</a></h3><p><code>clean-webpack-plugin</code> 清除打包目录 <code>html-webpack-plugin</code> 自动生成html文件</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HtmlWebpackPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  template: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./public/index.html&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p><code>copy-webpack-plugin</code> 拷贝静态资源</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CopyPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    { from: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./public&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, to: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span></code></pre></div><p>file-loader: 生成依赖的文件到输出目录，然后将模块文件设置为：导出一个路径<br> url-loader: 生成依赖的文件到输出目录，然后将模块文件设置为:导出一个URL <strong>解决路径问题</strong> 当产生路径时，loader或plugin只有相对于dist目录的路径，并不知道该路径将在哪个资源中使用，从而无法确定最终正确的路径。面对这种情况，需要依靠webpack的配置publicPath解决</p><h2 id="css工程化" tabindex="-1">css工程化 <a class="header-anchor" href="#css工程化" aria-label="Permalink to &quot;css工程化&quot;">​</a></h2><h3 id="抽离css" tabindex="-1">抽离css <a class="header-anchor" href="#抽离css" aria-label="Permalink to &quot;抽离css&quot;">​</a></h3><p>目前，css代码被css-loader转换后，交给的是style-loader进行处理。</p><p>style-loader使用的方式是用一段js代码，将样式加入到style元素中。</p><p>而实际的开发中，我们往往希望依赖的样式最终形成一个css文件</p><p><code>mini-css-extract-plugin</code></p><p>该库提供了1个plugin和1个loader</p><ul><li>plugin：负责生成css文件</li><li>loader：负责记录要生成的css文件的内容，同时导出开启css-module后的样式对象</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MiniCssExtractPlugin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;mini-css-extract-plugin&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    module: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        rules: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                test:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#22863A;--shiki-light-font-weight:bold;--shiki-dark:#85E89D;--shiki-dark-font-weight:bold;">\\.</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">css</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, use: [MiniCssExtractPlugin.loader, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;css-loader?modules&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    plugins: [</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MiniCssExtractPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//负责生成css文件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>配置生成的文件名</p><p>同output.filename的含义一样，即根据chunk生成的样式文件名</p><p>配置生成的文件名，例如[name].[contenthash:5].css</p><p>默认情况下，每个chunk对应一个css文件</p><h3 id="拆分css" tabindex="-1">拆分css <a class="header-anchor" href="#拆分css" aria-label="Permalink to &quot;拆分css&quot;">​</a></h3><p>要拆分css，就必须把css当成像js那样的模块；要把css当成模块，就必须有一个构建工具（webpack），它具备合并代码的能力</p><p>而webpack本身只能读取css文件的内容、将其当作JS代码进行分析，因此，会导致错误</p><p>于是，就必须有一个loader，能够将css代码转换为js代码</p><ol><li><code>css-loader</code> css-loader的作用，就是将css代码转换为js代码</li></ol><ul><li>将css文件的内容作为字符串导出</li><li>将css中的其他依赖作为require导入，以便webpack分析依赖</li></ul><p>它的处理原理极其简单：将css代码作为字符串导出, 类似：</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./reset.css&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.red</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;#f40&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    background</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">url</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./bg.png&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>转换为</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> import1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./reset.css&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> import2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./bg.png&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">import1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.red{</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    color:&quot;#f40&quot;;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    background:url(&quot;\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">import2</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}&quot;)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><ol start="2"><li><code>style-loader</code> 用于将css代码插入到style标签中，并且在style标签中设置scope属性，以便css模块化</li></ol><h2 id="js兼容性" tabindex="-1">js兼容性 <a class="header-anchor" href="#js兼容性" aria-label="Permalink to &quot;js兼容性&quot;">​</a></h2><p>babel的出现，就是用于解决这样的问题，它是一个编译器，可以把不同标准书写的语言，编译为统一的、能被各种浏览器识别的语言</p><p>babel有多种预设，最常见的预设是@babel/preset-env</p><h2 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h2><p><img src="`+h+`" alt=""></p><h2 id="打包体积-优化思路" tabindex="-1">打包体积 优化思路 <a class="header-anchor" href="#打包体积-优化思路" aria-label="Permalink to &quot;打包体积 优化思路&quot;">​</a></h2><ul><li>提取第三方库或通过引用外部文件的方式引入第三方库</li><li>代码压缩插件<code>UglifyJsPlugin</code></li><li>服务器启用 gzip 压缩</li><li>按需加载资源文件 <code>require.ensure</code></li><li>优化<code>devtool</code>中的<code>source-map</code></li><li>剥离<code>css</code>文件，单独打包</li><li>去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致</li></ul><p><a href="https://www.jianshu.com/p/6b526cc31ba7" target="_blank" rel="noreferrer">https://www.jianshu.com/p/6b526cc31ba7</a></p><h2 id="打包效率" tabindex="-1">打包效率 <a class="header-anchor" href="#打包效率" aria-label="Permalink to &quot;打包效率&quot;">​</a></h2><ul><li>开发环境采用增量构建，启用热更新</li><li>开发环境不做无意义的工作如提取<code>css</code>计算文件 hash 等</li><li>配置<code>devtool</code></li><li>选择合适的<code>loader</code></li><li>个别<code>loader</code>开启<code>cache</code> 如<code>babel-loader</code></li><li>第三方库采用引入方式</li><li>提取公共代码</li><li>优化构建时的搜索路径 指明需要构建目录及不需要构建目录</li><li>模块化引入需要的部分</li></ul><h2 id="plugin-怎么使用-webpack-对项目进行优化" tabindex="-1">plugin，怎么使用 webpack 对项目进行优化 <a class="header-anchor" href="#plugin-怎么使用-webpack-对项目进行优化" aria-label="Permalink to &quot;plugin，怎么使用 webpack 对项目进行优化&quot;">​</a></h2><p><strong>构建优化</strong></p><ul><li>减少编译体积 <code>ContextReplacementPugin</code>、<code>IgnorePlugin</code>、<code>babel-plugin-import</code>、<code>babel-plugin-transform-runtime</code></li><li>并行编译 <code>happypack</code>、<code>thread-loader</code>、<code>uglifyjsWebpackPlugin</code>开启并行</li><li>缓存 <code>cache-loader</code>、<code>hard-source-webpack-plugin</code>、<code>uglifyjsWebpackPlugin</code>开启缓存、<code>babel-loader</code>开启缓存</li><li>预编译 <code>dllWebpackPlugin &amp;&amp; DllReferencePlugin</code>、<code>auto-dll-webapck-plugin</code></li></ul><p><strong>性能优化</strong></p><ul><li>减少编译体积 <code>Tree-shaking</code>、<code>Scope Hositing</code></li><li><code>hash</code>缓存 <code>webpack-md5-plugin</code></li><li>拆包 <code>splitChunksPlugin</code>、<code>import()</code>、<code>require.ensure</code></li></ul><h2 id="补充" tabindex="-1">补充 <a class="header-anchor" href="#补充" aria-label="Permalink to &quot;补充&quot;">​</a></h2><h2 id="模块化原理" tabindex="-1">模块化原理 <a class="header-anchor" href="#模块化原理" aria-label="Permalink to &quot;模块化原理&quot;">​</a></h2><p><strong>构建优化</strong></p><p><a href="https://juejin.cn/post/6923991709667819534" target="_blank" rel="noreferrer">https://juejin.cn/post/6923991709667819534</a></p><p><a href="https://juejin.cn/post/6844904109775028238" target="_blank" rel="noreferrer">https://juejin.cn/post/6844904109775028238</a></p><h2 id="打包流程和基本实现" tabindex="-1">打包流程和基本实现 <a class="header-anchor" href="#打包流程和基本实现" aria-label="Permalink to &quot;打包流程和基本实现&quot;">​</a></h2><p><img src="https://pic3.zhimg.com/80/v2-658430a76ce1ea9c21ff37ce2006723a_720w.png" alt=""></p><p>参考1：<a href="https://zhuanlan.zhihu.com/p/101541041" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/101541041</a></p><p>参考2：<a href="https://zhuanlan.zhihu.com/p/371999555" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/371999555</a></p><ul><li>webpack 构建流程</li></ul><p>Webpack 的运行流程是一个串行的过程,从启动到结束会依次执行以下流程 :</p><ul><li>初始化参数：从配置文件和 Shell 语句中读取与合并参数,得出最终的参数。</li><li>开始编译：用上一步得到的参数初始化 Compiler 对象,加载所有配置的插件,执行对象的 run 方法开始执行编译。</li><li>确定入口：根据配置中的 entry 找出所有的入口文件。</li><li>编译模块：从入口文件出发,调用所有配置的 Loader 对模块进行翻译,再找出该模块依赖的模块,再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。</li><li>完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后,得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。</li><li>输出资源：根据入口和模块之间的依赖关系,组装成一个个包含多个模块的 Chunk,再把每个 Chunk 转换成一个单独的文件加入到输出列表,这步是可以修改输出内容的最后机会。</li><li>输出完成：在确定好输出内容后,根据配置确定输出的路径和文件名,把文件内容写入到文件系统。</li></ul><p><strong>webpack的打包原理是什么</strong></p><p>webpack打包原理是根据文件间的依赖关系对其进行静态分析，将这些模块按指定规则生成静态资源，当webpack处理程序时，它会递归地构建一个依赖关系图，将所有这些模块打包成一个或多个bundle。</p><p>webpack有两种组织模块的依赖方式，同步、异步。异步依赖将作为分割点，形成一个新的块；在优化了依赖树之后，每一个异步区块都将作为一个文件被打包。</p><p>webpack有一个智能解析器，几乎可以处理任何第三方库。无论它们的模块形式是CommonJS、AMD还是普通的JS文件；甚至在加载依赖的时候，允许使用动态表require(&quot;、/templates/&quot;+name+&quot;、jade&quot;)。</p><p>要承担如下功能： 打包：将多个文件 打包成 一个文件，减少服务器压力和下载带宽 转换：将预编译语言 转换成 浏览器识别的语言 优化：性能优化</p><p>webpack 特点：</p><p><strong>代码拆分</strong></p><p>webpack 有两种组织模块的依赖方式，同步、异步 异步依赖将作为分割点，形成一个新的块；在优化了依赖树之后，每一个异步区块都将作为一个文件被打包</p><p><strong>智能解析</strong></p><p>webpack 有一个智能解析器，几乎可以处理任何第三方库 无论它们的模块形式是 CommonJS、 AMD 还是普通的 JS 文件；甚至在加载依赖的时候，允许使用动态表达式 require(&quot;./templates/&quot; + name + &quot;.jade&quot;)</p><p><strong>快速运行</strong></p><p>webpack 使用异步 I/O 、多级缓存提高运行效率，使得 webpack 以难以令人置信的速度 快速增量编译</p><h2 id="vite和webpack的优缺点" tabindex="-1">vite和webpack的优缺点 <a class="header-anchor" href="#vite和webpack的优缺点" aria-label="Permalink to &quot;vite和webpack的优缺点&quot;">​</a></h2><p><a href="https://cloud.tencent.com/developer/article/1952175" target="_blank" rel="noreferrer">https://cloud.tencent.com/developer/article/1952175</a></p><p>webpack:</p><p>识别文件入口，逐层解析将代码转换成AST抽象语法树，再转换成浏览器可以识别的代码</p><p>冷启动缓慢</p><p>热更新效率低下</p><p>vite:</p><p>利用浏览器会对设置为module的script标签自动请求，并递归请求内部需求的特点，劫持这些请求，直接返回项目中文件，没有打包编译，速度快</p><p>Vite 通过在一开始将应用中的模块区分为 依赖 和 源码 两类，改进了开发服务器启动时间。使用GO编写的ESBuild.</p><p>让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入的代码，即只在当前屏幕上实际使用时才会被处理。</p><p>HMR 是在原生 ESM 上执行的。当编辑一个文件时，Vite 只需要精确地使已编辑的模块与其最近的 HMR 边界之间的链失效（大多数时候只需要模块本身），使 HMR 更新始终快速，无论应用的大小。Vite 同时利用 HTTP 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 304 Not Modified 进行协商缓存，而依赖模块请求则会通过 Cache-Control: max-age=31536000,immutable 进行强缓存，因此一旦被缓存它们将不需要再次请求。</p><p>缺点：生态不行，打包用的rollup，esbuild对于js和css代码分割不友好</p><h2 id="webpack5更新了什么" tabindex="-1">webpack5更新了什么 <a class="header-anchor" href="#webpack5更新了什么" aria-label="Permalink to &quot;webpack5更新了什么&quot;">​</a></h2><h3 id="清除输出目录" tabindex="-1">清除输出目录 <a class="header-anchor" href="#清除输出目录" aria-label="Permalink to &quot;清除输出目录&quot;">​</a></h3><p><code>webpack5</code>清除输出目录开箱可用，无须安装<code>clean-webpack-plugin</code>，具体做法如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  output: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    clean: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="top-level-await" tabindex="-1">top-level-await <a class="header-anchor" href="#top-level-await" aria-label="Permalink to &quot;top-level-await&quot;">​</a></h3><p><code>webpack5</code>现在允许在模块的顶级代码中直接使用<code>await</code></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// src/index.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> resp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http://www.baidu.com&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> jsonBody</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> resp.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">json</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> jsonBody;</span></span></code></pre></div><p>目前，<code>top-level-await</code>还未成为正式标准，因此，对于<code>webpack5</code>而言，该功能是作为<code>experiments</code>发布的，需要在<code>webpack.config.js</code>中配置开启</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// webpack.config.js</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  experiments: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    topLevelAwait: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h3 id="打包体积优化" tabindex="-1">打包体积优化 <a class="header-anchor" href="#打包体积优化" aria-label="Permalink to &quot;打包体积优化&quot;">​</a></h3><p><code>webpack5</code>对模块的合并、作用域提升、<code>tree shaking</code>等处理更加智能</p><h3 id="打包缓存开箱即用" tabindex="-1">打包缓存开箱即用 <a class="header-anchor" href="#打包缓存开箱即用" aria-label="Permalink to &quot;打包缓存开箱即用&quot;">​</a></h3><p>在<code>webpack4</code>中，需要使用<code>cache-loader</code>缓存打包结果以优化之后的打包性能</p><p>而在<code>webpack5</code>中，默认就已经开启了打包缓存，无须再安装<code>cache-loader</code></p><p>默认情况下，<code>webpack5</code>是将模块的打包结果缓存到内存中，可以通过<code>cache</code>配置进行更改</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;path&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  cache: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 缓存类型，支持：memory、filesystem</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;filesystem&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 缓存目录，仅类型为 filesystem 有效</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cacheDirectory: path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__dirname, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;node_modules/.cache/webpack&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><blockquote><p>关于<code>cache</code>的更多配置参考：<a href="https://webpack.docschina.org/configuration/other-options/#cache" target="_blank" rel="noreferrer">https://webpack.docschina.org/configuration/other-options/#cache</a></p></blockquote><h3 id="资源模块" tabindex="-1">资源模块 <a class="header-anchor" href="#资源模块" aria-label="Permalink to &quot;资源模块&quot;">​</a></h3><p>在<code>webpack4</code>中，针对资源型文件我们通常使用<code>file-loader</code>、<code>url-loader</code>、<code>raw-loader</code>进行处理</p><p>由于大部分前端项目都会用到资源型文件，因此<code>webpack5</code>原生支持了资源型模块</p><p>详见：<a href="https://webpack.docschina.org/guides/asset-modules/" target="_blank" rel="noreferrer">https://webpack.docschina.org/guides/asset-modules/</a></p>`,137)]))}const y=i(k,[["render",c]]);export{b as __pageData,y as default};
