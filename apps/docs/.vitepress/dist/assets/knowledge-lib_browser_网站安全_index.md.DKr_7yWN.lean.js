import{a2 as s,t as a,ao as t,q as e}from"./chunks/framework.tQiMsDJj.js";const d=JSON.parse('{"title":"常见web安全及防护原理","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge-lib/browser/网站安全/index.md","filePath":"knowledge-lib/browser/网站安全/index.md"}'),l={name:"knowledge-lib/browser/网站安全/index.md"};function n(p,i,h,k,r,E){return e(),a("div",null,i[0]||(i[0]=[t(`<h1 id="常见web安全及防护原理" tabindex="-1">常见web安全及防护原理 <a class="header-anchor" href="#常见web安全及防护原理" aria-label="Permalink to &quot;常见web安全及防护原理&quot;">​</a></h1><h2 id="sql注入原理" tabindex="-1"><code>sql</code>注入原理 <a class="header-anchor" href="#sql注入原理" aria-label="Permalink to &quot;\`sql\`注入原理&quot;">​</a></h2><ul><li>就是通过把<code>SQL</code>命令插入到<code>Web</code>表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令</li><li>总的来说有以下几点 <ul><li>永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双<code>&quot;-&quot;</code>进行转换等</li><li>永远不要使用动态拼装SQL，可以使用参数化的<code>SQL</code>或者直接使用存储过程进行数据查询存取</li><li>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接</li><li>不要把机密信息明文存放，请加密或者<code>hash</code>掉密码和敏感的信息</li></ul></li></ul><h2 id="xss攻击" tabindex="-1">XSS攻击 <a class="header-anchor" href="#xss攻击" aria-label="Permalink to &quot;XSS攻击&quot;">​</a></h2><p><strong>XSS原理及防范</strong></p><ul><li><code>Xss(cross-site scripting)</code>攻击指的是攻击者往<code>Web</code>页面里插入恶意<code>html</code>标签或者<code>javascript</code>代码。不需要你做任何的登录认证，它会通过合法的操作（比如在 url 中输入、在评论框中 输入），向你的页面注入脚本（可能是 js、hmtl 代码块等）。</li><li>后果：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取<code>cookie</code>中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点</li></ul><p><strong>XSS防范方法</strong></p><ul><li>首先代码里对用户输入的地方和变量都需要仔细检查长度和对<code>”&lt;”,”&gt;”,”;”,”’”</code>等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把<code>html tag</code> 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击</li><li>编码：对用户输入的数据进行 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Entity" target="_blank" rel="noreferrer">HTML Entity</a> 编码。把字符转换成 转义字符。Encode 的作用是将$var 等一些字符进行转化，使得浏览器在最终输出结果上是一样的。</li><li>CSP: CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 只允许加载本站资源</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Content</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Security</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Policy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">default-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">src ‘self’</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 只允许加载 HTTPS 协议图片</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Content</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Security</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Policy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: img</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">src </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">https</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//*</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 允许加载任何来源框架</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Content</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Security</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Policy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: child</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">src </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;none&#39;</span></span></code></pre></div><ul><li><code>HttpOnly</code> 类型的 Cookie 用于阻止了 JavaScript 对其的访问性而能在一定程度上缓解此类攻击。</li></ul><h2 id="csrf攻击" tabindex="-1">CSRF攻击 <a class="header-anchor" href="#csrf攻击" aria-label="Permalink to &quot;CSRF攻击&quot;">​</a></h2><p><strong>什么是CSRF</strong></p><p>（Cross Site Request Forgery, 跨站域请求伪造）是一种网络的攻击方式，CSRF通过<code>伪装来自受信任用户</code>的请求来利用受信任的网站。与<a href="https://link.jianshu.com?t=http://baike.baidu.com/view/50325.htm" target="_blank" rel="noreferrer">XSS</a>攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和<code>难以防范</code>，所以被认为比<a href="https://link.jianshu.com?t=http://baike.baidu.com/view/50325.htm" target="_blank" rel="noreferrer">XSS</a><code>更具危险性</code>。</p><p><img src="https://pic1.zhimg.com/80/v2-05b0dd2744a82edca44ff41da4f68698_720w.jpg" alt="img"></p><ul><li><p>GET类型</p><ul><li><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">img</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">http://wooyun.org/csrf?xx</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span></code></pre></div></li><li><p>在访问含有这个img的页面后，成功向<code>http://wooyun.org/csrf?xx=11</code> 发出了一次HTTP请求。所以，如果将该网址替换为存在GET型CSRF的地址，就能完成攻击了。</p></li></ul></li><li><p>POST类型</p><ul><li><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">form</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">http://wooyun.org/csrf.php</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> method</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">POST</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;xx&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;11&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">form</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; document.forms[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">submit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li><li><p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。</p></li></ul></li></ul><p><strong>防御CSRF</strong></p><ul><li><strong>1 验证HTTP Referer字段</strong></li></ul><p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，因此，要防御 CSRF 攻击，网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p><p>缺点：</p><ul><li>Referer由浏览器实现，这种方法是把安全性都依赖于第三方（即浏览器）来保障事实上； <ul><li>对于某些浏览器，比如<code>IE6 或 FF2</code>，目前已经有一些方法可以篡改 Referer 值。如果 网站支持<code>IE6 浏览器</code>，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。</li></ul></li><li>即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</li><li>当将攻击页面（包含form提交）以base64编码直接付给iframe的src时，不会产生referencer字段，因此无法防御CSRF</li></ul><ul><li><strong>2 在请求地址中添加token并验证</strong></li></ul><p>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中（真实的），因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。</p><p>这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <a href="https://link.jianshu.com?t=http://url?csrftoken=tokenvalue" target="_blank" rel="noreferrer">http://url?csrftoken=tokenvalue</a>。 而对于 POST 请求来说，要在 form 的最后加上 <input type="hidden" name="csrftoken" value="tokenvalue">，这样就把 token 以参数的形式加入请求了。</p><p>要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p><p>问题：对于网站中的各种请求，如何都添加上token</p><p>博客类网站，黑客发表了一个网址，如何保证跳转后的安全？</p><p>像知乎等会进行提示</p><ul><li><strong>3 在HTTP头中自定义属性并验证</strong></li></ul><p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。 然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p><ul><li><p><strong>4 设置SameSite</strong></p><ul><li>SameSite=Strict：</li></ul></li></ul><p>严格模式，表明这个 cookie 在任何情况下都不可能作为第三方 cookie，绝无例外。比如说假如 b.com 设置了如下 cookie：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Set-Cookie: foo=1; SameSite=Strict</span></span>
<span class="line"><span>Set-Cookie: bar=2</span></span></code></pre></div><p>你在 a.com 下发起的对 b.com 的任意请求中，foo 这个 cookie 都不会被包含在 Cookie 请求头中，但 bar 会。举个实际的例子就是，假如淘宝网站用来识别用户登录与否的 cookie 被设置成了 SameSite=Strict，那么用户从百度搜索页面甚至天猫页面的链接点击进入淘宝后，淘宝都不会是登录状态，因为淘宝的服务器不会接受到那个 cookie，其它网站发起的对淘宝的任意请求都不会带上那个 cookie。</p><ul><li>SameSite=Lax：</li></ul><p>宽松模式，比 Strict 放宽了点限制：假如这个请求是我上面总结的那种同步请求（改变了当前页面或者打开了新页面）且同时是个 GET 请求（因为从语义上说 GET 是读取操作，比 POST 更安全），则这个 cookie 可以作为第三方 cookie。比如说假如 b.com 设置了如下 cookie：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Set-Cookie: foo=1; SameSite=Strict</span></span>
<span class="line"><span>Set-Cookie: bar=2; SameSite=Lax</span></span>
<span class="line"><span>Set-Cookie: baz=3</span></span></code></pre></div><p>当用户从 a.com 点击链接进入 b.com 时，foo 这个 cookie 不会被包含在 Cookie 请求头中，但 bar 和 baz 会，也就是说用户在不同网站之间通过链接跳转是不受影响了。但假如这个请求是从 a.com 发起的对 b.com 的异步请求，或者页面跳转是通过表单的 post 提交触发的，则 bar 也不会发送。</p><ul><li>该用哪种模式？</li></ul><p>该用哪种模式，要看你的需求。比如你的网站是一个少数人使用的后台管理系统，所有人的操作方式都是从自己浏览器的收藏夹里打开网址，那我看用 Strict 也无妨。如果你的网站是微博，用了 Strict 会这样：有人在某个论坛里发了帖子“快看这个微博多搞笑 <a href="http://weibo.com/111111/aaaaaa%E2%80%9D%EF%BC%8C%E7%BB%93%E6%9E%9C%E4%B8%8B%E9%9D%A2%E4%BA%BA%E9%83%BD%E5%9B%9E%E5%A4%8D%E2%80%9C%E6%89%93%E4%B8%8D%E5%BC%80%E5%95%8A%E2%80%9D%EF%BC%9B%E5%A6%82%E6%9E%9C%E4%BD%A0%E7%9A%84%E7%BD%91%E7%AB%99%E6%98%AF%E6%B7%98%E5%AE%9D%EF%BC%8C%E7%94%A8%E4%BA%86" target="_blank" rel="noreferrer">http://weibo.com/111111/aaaaaa”，结果下面人都回复“打不开啊”；如果你的网站是淘宝，用了</a> Strict 会这样：某微商在微博上发了条消息“新百伦正品特卖5折起 <a href="https://item.taobao.com/item.htm?id=1111111%E2%80%9D%EF%BC%8C%E7%BB%93%E6%9E%9C%E7%82%B9%E8%BF%9B%E5%8E%BB%E9%A1%BE%E5%AE%A2%E4%B9%B0%E4%B8%8D%E4%BA%86%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%EF%BC%8C%E8%BF%99%E7%A7%8D%E8%B6%85%E5%A4%9A%E7%94%A8%E6%88%B7%E7%9A%84%E3%80%81%E5%8F%AF%E8%83%BD%E7%BB%8F%E5%B8%B8%E9%9C%80%E8%A6%81%E7%94%A8%E6%88%B7%E4%BB%8E%E5%88%AB%E7%9A%84%E7%BD%91%E7%AB%99%E7%82%B9%E8%BF%87%E6%9D%A5%E7%9A%84%E7%BD%91%E7%AB%99%EF%BC%8C%E5%B0%B1%E4%B8%8D%E9%80%82%E5%90%88%E7%94%A8" target="_blank" rel="noreferrer">https://item.taobao.com/item.htm?id=1111111”，结果点进去顾客买不了，也就是说，这种超多用户的、可能经常需要用户从别的网站点过来的网站，就不适合用</a> Strict 了。</p><p>假如你的网站有用 iframe 形式嵌在别的网站里的需求，那么连 Lax 你也不能用，因为 iframe 请求也是一种异步请求。或者假如别的网站有使用你的网站的 JSONP 接口，那么同样 Lax 你也不能用，比如天猫就是通过淘宝的 JSONP 接口来判断用户是否登录的。</p><p>有时安全性和灵活性就是矛盾的，需要取舍。</p><h2 id="中间人攻击-mitm-man-in-the-middle" tabindex="-1">中间人攻击（MITM, man in the middle） <a class="header-anchor" href="#中间人攻击-mitm-man-in-the-middle" aria-label="Permalink to &quot;中间人攻击（MITM, man in the middle）&quot;">​</a></h2><p>中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。通常来说不建议使用公共的 Wi-Fi，因为很可能就会发生中间人攻击的情况。如果你在通信的过程中涉及到了某些敏感信息，就完全暴露给攻击方了。</p><p>当然防御中间人攻击其实并不难，只需要增加一个安全通道来传输信息。HTTPS 就可以用来防御中间人攻击，但是并不是说使用了 HTTPS 就可以高枕无忧了，因为如果你没有完全关闭 HTTP 访问的话，攻击方可以通过某些方式将 HTTPS 降级为 HTTP 从而实现中间人攻击。</p><h2 id="点击劫持" tabindex="-1">点击劫持 <a class="header-anchor" href="#点击劫持" aria-label="Permalink to &quot;点击劫持&quot;">​</a></h2><p>点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。</p><p><strong>防御</strong></p><p><code>X-FRAME-OPTIONS</code>:</p><ul><li><code>DENY</code>，表示页面不允许通过 iframe 的方式展示</li><li><code>SAMEORIGIN</code>，表示页面可以在相同域名下通过 iframe 的方式展示</li><li><code>ALLOW-FROM</code>，表示页面可以在指定来源的 iframe 中展示</li></ul><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;click-jack&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">none</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !important</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // js主动判断当前页面是否处于iframe中，如果是禁止显示</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (self </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> top) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> style </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;click-jack&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(style)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      top.location </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> self.location</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h2 id="dos和ddos" tabindex="-1">DOS和DDOS <a class="header-anchor" href="#dos和ddos" aria-label="Permalink to &quot;DOS和DDOS&quot;">​</a></h2><p>1）DOS攻击侧重于通过对服务器特定的漏洞，利用DOS攻击导致网络连接失败、系统崩溃、电脑死机等情况的发生。 2）DDOS攻击则通过很多“僵尸主机”向目标主机发送大量“看似”合法的流量包，从而造成网络阻塞或服务器资源耗尽而导致拒绝服务。 例如TCP首包丢弃方案，防护：</p><ol><li>限制请求</li><li>限制连接的数量</li><li>增加内存</li><li>分布式集群防御：这是目前网络安全界防御大规模DDOS攻击的最有效方法</li><li>买云盾 例如阿里高防，百度云加速 电信的云提</li></ol><h1 id="安全相关响应头" tabindex="-1">安全相关响应头 <a class="header-anchor" href="#安全相关响应头" aria-label="Permalink to &quot;安全相关响应头&quot;">​</a></h1><p>参考：<a href="https://blog.csdn.net/qq_37788558/article/details/105460837" target="_blank" rel="noreferrer">https://blog.csdn.net/qq_37788558/article/details/105460837</a></p><p><code>X-Frame-Options</code>是为了减少点击劫持（Clickjacking, 即防止被其他页面iframe引用）而引入的一个响应头。</p><ul><li><code>DENY</code>：不允许被任何页面嵌入；</li><li><code>SAMEORIGIN</code>：不允许被本域以外的页面嵌入；</li><li><code>ALLOW-FROM uri</code>：不允许被指定的域名以外的页面嵌入（Chrome现阶段不支持）；</li></ul><p><code>X-XSS-Protection</code>这个响应头是用来防范XSS的</p><ul><li>0：禁用XSS保护；</li><li>1：启用XSS保护；启用XSS保护，并在检查到XSS攻击时，停止渲染页面（例如IE8中，检查到攻击时，整个页面会被一个#替换）；</li></ul><p><code>X-Content-Type-Options: nosniff</code>这个响应头的值只能是 nosniff，可用于IE8+和Chrome。另外，它还被Chrome用于扩展下载，通过下面这个响应头可以禁用</p><p><strong>浏览器的类型猜测行为</strong>：</p><p>互联网上的资源有各种类型，通常浏览器会根据响应头的 Content-Type 字段来分辨它们的类型。 例如：text/html 代表html文档，image/png是PNG图片，text/css是CSS样式文档。</p><p>然而，有些资源的 Content-Type 是错的或者未定义。这时，某些浏览器会启用 MIME-sniffing 来猜测该资源的类型，解析内容并执行。</p><p>例如，我们即使给一个html文档指定Content-Type为text/plain，在IE8-中这个文档依然会被当做html来解析。利用浏览器的这个特性，攻击者甚至可以让原本应该解析为图片的请求被解析为JavaScript。</p><p><code>Strict-Transport-Security</code>HTTP Strict Transport Security，简称为 HSTS 。它允许一个HTTPS网站，要求浏览器总是通过HTTPS来访问它。我们知道HTTPS相对于HTTP有更好的安全性，而很多HTTPS网站，也可以通过HTTP来访问。开发人员的失误或者用户主动输入地址，都有可能导致用户以HTTP访问网站，降低了安全性。一般，我们会通过Web Server发送301/302重定向来解决这个问题。 现在有了HSTS，可以让浏览器帮你做这个跳转，省一次HTTP请求。另外，浏览器本地替换可以保证只会发送HTTPS请求，避免被劫持。</p><p><code>X-Content-Security-Policy</code></p><ul><li>Content Security Policy，简称 CSP。这个规范与内容安全有关，主要是用来定义页面可以加载哪些资源，减少 XSS 的发生。</li></ul>`,67)]))}const c=s(l,[["render",n]]);export{d as __pageData,c as default};
