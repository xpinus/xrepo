import{a2 as l,t as i,ao as o,q as t}from"./chunks/framework.tQiMsDJj.js";const h=JSON.parse('{"title":"插件 API","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge-lib/engineering/构建/vite/插件/index.md","filePath":"knowledge-lib/engineering/构建/vite/插件/index.md"}'),a={name:"knowledge-lib/engineering/构建/vite/插件/index.md"};function r(d,e,n,c,u,p){return t(),i("div",null,e[0]||(e[0]=[o('<h1 id="插件-api" tabindex="-1">插件 API <a class="header-anchor" href="#插件-api" aria-label="Permalink to &quot;插件 API&quot;">​</a></h1><blockquote><p>本质是一个带有一系列属性、回调函数的对象</p></blockquote><p>Vite 插件扩展了设计出色的 Rollup 接口，带有一些 Vite 独有的配置项。因此，你只需要编写一个 Vite 插件，就可以同时为开发环境和生产环境工作</p><blockquote><p>约定</p></blockquote><p>如果插件不使用 Vite 特有的钩子，可以作为 兼容 Rollup 的插件 来实现，推荐使用 Rollup 插件名称约定：</p><ul><li>有一个带 rollup-plugin- 前缀、语义清晰的名称</li><li>在 package.json 中包含 rollup-plugin 和 vite-plugin 关键字</li></ul><p>对于 Vite 专属的插件：</p><ul><li>有一个带 vite-plugin- 前缀、语义清晰的名称，你的插件只适用于特定的框架，应在追加上框架名</li><li>在 package.json 中包含 vite-plugin 关键字</li></ul><h2 id="插件配置" tabindex="-1">插件配置 <a class="header-anchor" href="#插件配置" aria-label="Permalink to &quot;插件配置&quot;">​</a></h2><ul><li>在 <code>plugins</code> 数组中配置插件</li><li>假值插件（插件返回的是undeifne\\null等假值不是一个配置）将被自动忽略</li><li>插件可以返回一个有插件构成的数组，该数组将被自动扁平化</li></ul><h2 id="钩子" tabindex="-1">钩子 <a class="header-anchor" href="#钩子" aria-label="Permalink to &quot;钩子&quot;">​</a></h2><h3 id="通用钩子" tabindex="-1">通用钩子 <a class="header-anchor" href="#通用钩子" aria-label="Permalink to &quot;通用钩子&quot;">​</a></h3><blockquote><p>在开发中，Vite 开发服务器会创建一个插件容器来调用 Rollup 构建钩子，与 Rollup 如出一辙</p></blockquote><ul><li>服务器启动时 <ul><li><code>options</code></li><li><code>buildStart</code></li></ul></li><li>每个传入模块请求时 <ul><li><code>resolvedId</code></li><li><code>load</code></li><li><code>transform</code></li></ul></li><li>服务器关闭时 <ul><li><code>buildEnd</code></li><li><code>closeBundle</code></li></ul></li></ul><blockquote><p>请注意 <code>moduleParsed</code> 钩子在开发中是<strong>不会</strong>被调用的，因为 Vite 为了性能会避免完整的 AST 解析</p></blockquote><blockquote><p>Output Generation Hooks（除了 closeBundle) 在开发中是 不会 被调用的。你可以认为 Vite 的开发服务器只调用了 rollup.rollup() 而没有调用 bundle.generate()。</p></blockquote><h3 id="vite独有钩子" tabindex="-1">Vite独有钩子 <a class="header-anchor" href="#vite独有钩子" aria-label="Permalink to &quot;Vite独有钩子&quot;">​</a></h3><ul><li><code>config</code>： <ul><li><code>(config: UserConfig, env: { mode: string, command: string }) =&gt; UserConfig | null | void</code></li><li>在解析 Vite 配置前调用。</li><li>钩子接收原始用户配置和配置环境的变量, command 为CLI指令</li><li>用户插件在运行这个钩子之前会被解析，因此在 config 钩子中注入其他插件不会有任何效果</li></ul></li><li><code>configResolved</code>: <ul><li><code>(config: ResolvedConfig) =&gt; void | Promise&lt;void&gt;</code></li><li><strong>在解析 Vite 配置后调用</strong></li><li>使用这个钩子读取和存储最终解析的配置</li></ul></li><li><code>configureServer</code>: <ul><li><code>(server: ViteDevServer) =&gt; (() =&gt; void) | void | Promise&lt;(() =&gt; void) | void&gt;</code></li><li>用于配置开发服务器的钩子</li><li>添加改变一些中间件</li><li>访问存储服务器</li><li>注意 configureServer 在运行生产版本时不会被调用，所以其他钩子需要防范它缺失</li></ul></li><li><code>configurePreviewServer</code>: <ul><li>与 configureServer 相同但是作为预览服务器</li></ul></li><li><code>transformIndexHtml</code>: <ul><li>转换 index.html 的专用钩子，钩子接收当前的 HTML 字符串和转换上下文</li><li>上下文在开发期间暴露ViteDevServer实例，在构建期间暴露 Rollup 输出的包</li><li>返回值 <ul><li>经过转换的 HTML 字符串</li><li>注入到现有 HTML 中的标签描述符对象数组（{ tag, attrs, children }）。每个标签也可以指定它应该被注入到哪里（默认是在 <code>&lt;head&gt;</code> 之前）</li></ul></li><li>一个包含 { html, tags } 的对象</li></ul></li><li><code>handleHotUpdate</code>: <ul><li>行自定义 HMR 更新处理</li></ul></li></ul><h2 id="插件执行顺序" tabindex="-1">插件执行顺序 <a class="header-anchor" href="#插件执行顺序" aria-label="Permalink to &quot;插件执行顺序&quot;">​</a></h2><blockquote><p>同级别会按照数组从前到后的顺序执行</p></blockquote><blockquote><p>插件可以额外指定一个 enforce 属性（类似于 webpack 加载器）来调整它的应用顺序。enforce 的值可以是pre 或 post。解析后的插件将按照以下顺序排列：</p></blockquote><ul><li>Alias</li><li>带有 enforce: &#39;pre&#39; 的用户插件，在 Vite 核心插件之后调用该插件</li><li>Vite 核心插件</li><li>没有 enforce 值的用户插件，在 Vite 核心插件之后调用该插件</li><li>Vite 构建用的插件</li><li>带有 enforce: &#39;post&#39; 的用户插件，在 Vite 构建插件之后调用该插件</li><li>Vite 后置构建插件（最小化，manifest，报告）</li><li>情景应用</li></ul><h2 id="插件应用情景" tabindex="-1">插件应用情景 <a class="header-anchor" href="#插件应用情景" aria-label="Permalink to &quot;插件应用情景&quot;">​</a></h2><p>默认情况下插件在开发（serve）和构建（build）模式中都会调用</p><p>使用<code>apply</code>属性指明它们仅在 &#39;build&#39; 或 &#39;serve&#39; 模式时调用</p><p>apply: &#39;build&#39;</p><h2 id="常用插件" tabindex="-1">常用插件 <a class="header-anchor" href="#常用插件" aria-label="Permalink to &quot;常用插件&quot;">​</a></h2><p>例如，要想为传统浏览器提供支持，可以按下面这样使用官方插件 @vitejs/plugin-legacy</p><h2 id="实现-约定大于配置-的自动路由配置插件" tabindex="-1">实现“约定大于配置”的自动路由配置插件 <a class="header-anchor" href="#实现-约定大于配置-的自动路由配置插件" aria-label="Permalink to &quot;实现“约定大于配置”的自动路由配置插件&quot;">​</a></h2>',29)]))}const g=l(a,[["render",r]]);export{h as __pageData,g as default};
