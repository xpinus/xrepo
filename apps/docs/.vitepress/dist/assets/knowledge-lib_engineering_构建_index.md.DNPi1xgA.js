import{a2 as l,t as i,ao as o,q as a}from"./chunks/framework.tQiMsDJj.js";const b=JSON.parse('{"title":"前端构建知识体系","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge-lib/engineering/构建/index.md","filePath":"knowledge-lib/engineering/构建/index.md"}'),t={name:"knowledge-lib/engineering/构建/index.md"};function r(c,e,p,n,u,d){return a(),i("div",null,e[0]||(e[0]=[o('<h1 id="前端构建知识体系" tabindex="-1">前端构建知识体系 <a class="header-anchor" href="#前端构建知识体系" aria-label="Permalink to &quot;前端构建知识体系&quot;">​</a></h1><h2 id="脚手架和构建工具" tabindex="-1">脚手架和构建工具 <a class="header-anchor" href="#脚手架和构建工具" aria-label="Permalink to &quot;脚手架和构建工具&quot;">​</a></h2><blockquote><p>构建工具：将代码从开发环境构建到生产环境</p></blockquote><ol><li>第一代构建工具：以 npm scripts、grunt、gulp 为代表的构建工具，这一代构建工具所做的事情主要就是编译、合并以及压缩等工作。</li><li>第二代构建工具：以 browserify、webpack、parcel、rollup 为代表的构建工具。这一代构建工具加强了对模块的处理，能够对模块的依赖关系进行处理，对模块进行合并打包。</li><li>第三代构建工具：主要就是往“锈化”的方向发展。就是使用 Rust 将前端工具链重构</li></ol><ul><li>Babel ---&gt; swc</li><li>PostCSS ---&gt; lightingCSS</li><li>Electron ---&gt; Tauri</li><li>ESLint ----&gt; dprint</li><li>Webpack ---&gt; Turbopack、Rspack</li><li>rollup ---&gt; rolldown</li></ul><blockquote><p>脚手架：帮助开发者搭建开发环境项目的工具，但是现代脚手架往往内置构建工具</p></blockquote><ul><li>VueCLI：内置了 webpack 作为构建工具</li><li>CreateReactApp：内置了 webpack 作为构建工具</li></ul><p><a href="https://juejin.cn/post/7147365025047379981/" target="_blank" rel="noreferrer">从零到亿系统性的建立前端构建知识体系</a></p><h2 id="模块化原理" tabindex="-1">模块化原理 <a class="header-anchor" href="#模块化原理" aria-label="Permalink to &quot;模块化原理&quot;">​</a></h2><blockquote><p>模块化的产生是为了解决什么问题？在什么场景下诞生的？</p></blockquote><ul><li>早期js开发存在<code>全局污染</code>和<code>依赖混乱</code>的问题</li><li>社区模块化方案 <ul><li>CommonJS <ul><li>最初由社区提出用在浏览器器之外，如node服务端，在node中<code>每一个js都是一个单独模块</code></li><li>使用<code>exports</code>、<code>module.exports</code>、<code>require</code></li><li>运行时</li></ul></li><li>AMD CMD UMD 为浏览器环境提出的模块化方案</li></ul></li><li>ES6官方提出的模块化方案<code>ES Module</code><ul><li>使用import export</li><li>静态导入导出的优势，实现了 tree shaking</li><li>可以 import() 懒加载方式实现代码分割</li></ul></li></ul><p>浏览器是仅支持ESM，node支持CJS\\ESM，构建工具支持更多, 如 Webpack 搭建的项目中，它是允许我们使用各种各样的模块化的。最常用的方式就是 CommonJS 和 ES Module。</p><blockquote><p><a href="https://es6.ruanyifeng.com/#docs/module-loader#ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82" target="_blank" rel="noreferrer">import和require的区别</a></p></blockquote><ul><li>出现的时间、地点(官方、社区)不同</li><li>浏览器服务器支持情况不同 <ul><li>原生浏览器不支持 require/exports，可使用支持 CommonJS 模块规范的 Browsersify、webpack 等打包工具，它们会将 require/exports 转换成能在浏览器使用的代码。</li><li>import/export 在浏览器中无法直接使用，我们需要在引入模块的 <code>&lt;script&gt;</code> 元素上添加type=&quot;module&quot; 属性。</li><li>即使 Node.js 13.2+ 可以通过修改文件后缀为 .mjs 来支持 ES6 模块 import/export，但是Node.js 官方不建议在正式环境使用。目前可以使用 babel 将 ES6 的模块系统编译成 CommonJS 规范</li></ul></li><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li><li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li><li>CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段。</li></ul><p><strong>那这些打包工具是如何实现模块化的呢？</strong></p><h3 id="webpack实现方式" tabindex="-1"><a href="./webpack/构建体系01-webpack模块化原理.html">webpack实现方式</a> <a class="header-anchor" href="#webpack实现方式" aria-label="Permalink to &quot;[webpack实现方式](./webpack/构建体系01-webpack模块化原理)&quot;">​</a></h3><h3 id="webpack懒加载原理" tabindex="-1"><a href="./webpack/构建体系02-webpack懒加载原理.html">webpack懒加载原理</a> <a class="header-anchor" href="#webpack懒加载原理" aria-label="Permalink to &quot;[webpack懒加载原理](./webpack/构建体系02-webpack懒加载原理)&quot;">​</a></h3><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>vite的实现方式？</p></div><h2 id="ast-抽象语法树" tabindex="-1"><a href="./AST.html">AST(抽象语法树)</a> <a class="header-anchor" href="#ast-抽象语法树" aria-label="Permalink to &quot;[AST(抽象语法树)](./AST)&quot;">​</a></h2><p>Ajax Interceptor : 一个谷歌插件，可以拦截页面上的 Ajax 请求，并把返回结果替换成任意文本。这对 mock 数据、排查线上问题 来说简直就是神器</p><p>chrome支持直接在线上环境添加 source-map 链接来定位问题</p><ul><li>环境、api兼容、语法兼容怎么处理</li><li>什么是syntax transformer runtime</li><li>什么是AST</li><li>厂商前缀、代码压缩、代码剪枝</li><li>webpack模块化查找规则</li><li>热更新</li><li>源码地图在做什么</li></ul>',22)]))}const m=l(t,[["render",r]]);export{b as __pageData,m as default};
