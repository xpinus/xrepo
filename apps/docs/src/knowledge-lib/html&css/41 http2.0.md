---
sort: 41
---

# http1.0，http1.1，http2，http3

## http1.0
HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上,是一种无状态、无连接的应用层协议，几年后被HTTP1.1代替并广泛使用

## http1.1
http1.1基于文本解析,把所有请求和响应作为纯文本
http1.1加入了缓存处理（强缓存和协商缓存）
http1.1拥有长连接，并支持请求管道化（pipelining），
http1.1流控制基于tcp连接。当连接建立时，两端通过系统默认机制建立缓冲区。并通过ack报文来通知对方接收窗口大小，因为http1.1 依靠传输层来避免流溢出，每个tcp连接需要一个独立的流控制机制

缓存处理（强缓存和协商缓存）
- 强缓存
强缓存不发送请求，直接读取资源，可以获得返回200的状态码
利用http头中的Expires和Cache-Control两个字段来控制，都用来表示资源的缓存时间，Expires能设置失效时间，而Cache-Control能做到更多选项更细致，如果同时设置的话，其优先级高于Expires
- 协商缓存
通过服务器来确定缓存资源是否可用，通过request header判断是否命中请求，命中后返回304状态码，并返回新的request header通知客户端从缓存里取
普通刷新会启用弱缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存
如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求
## http2
http2相比于http1.1，性能大幅度提升

http2通过一个连接来多路复用

http2拥有头部压缩

http2拥有新的二进制格式，使用二进制框架层把所有消息封装成二进制，且仍然保持http语法

http2允许客户端和服务器端实现他们自己的流控制机制，而不是依赖传输层,两端在传输层交换可用的缓冲区大小，来让他们在多路复用流上设置自己的接收窗口

http2让服务器可以将响应主动“推送”到客户端缓存中

- htpp2头部压缩
http2头部压缩又称为HAPCK，设计简单而灵活，是因为HPACK格式有意地简单且不灵活能降低由于实现错误而导致的互操作性或安全问题的风险
http1.1没有头部压缩，随着请求增加，冗余头部字段会不必要地占用带宽，从而显着增加延迟，而头部压缩可消除冗余报头字段，限制已知安全攻击的漏洞，并且在受限环境中使用有限的内存要求
- http2多路复用
http 性能优化的关键并不在于高带宽，而是低延迟
tcp 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度,这种调谐则被称为 tcp 慢启动,由于这种原因，让原本就具有突发性和短时性的 http 连接变的十分低效
http/2 通过让所有数据流共用同一个连接，可以更有效地使用 tcp 连接，让高带宽也能真正的服务于 http 的性能提升。而http1.1存在低性能的线头阻塞，一旦有一个请求超时，便会出现阻塞等待的情况
## http3
之前说了http2，那么http3就是为了解决http2相关问题而诞生，它基于一个新的传输层协议QUIC，而http3就是建立一个在QUIC上运行的HTTP新规范，而http3之前的版本都是基于TCP，QUIC就是为了替代TCP，解决TCP的一些缺陷

tcp
不支持流级复用，TCP会将所有对象序列化在同一个流中，因此，它不知道TCP段的对象级分区，无法在同一个流中复用数据包
会产生冗余通信，三次连接握手会有冗余的消息交换序列
可能会间歇性地挂起数据传输，tcp中有个因为序列顺序处理丢失的问题的缺陷称为行头阻塞

QUIC
同样拥有头部压缩，并优化了对乱序发送的支持，也优化了压缩率
放弃tcp，通过udp建立，提高了连接建立的速度，降低了延迟
tcp本身是无法解决**队头拥塞**（https://zhuanlan.zhihu.com/p/330300133），quic则解决了这个问题
Connection ID使得http3支持连接迁移以及NAT的重绑定

## HTTP1.0对比HTTP1.1, HTTP1.1主要改进了以下几点内容

keep-alive
客户端缓存
连接代宽优化
请求Host域
请求状态码
请求方法

- keep-alive
在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。

建立起一个 TCP 连接需要经过“三次握手”：
第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连 接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”（过程就不细写了，就是服务器和客户端交互，最终确定断开）

HTTP 1.1持久连接（PersistentConnection）在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭TCP连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

- 客户端缓存
在HTTP/1.0中，使用Expire头域来判断资源的fresh或stale，并使用条件请求（conditional request）来判断资源是否仍有效。例如，cache服务器通过If-Modified-Since头域向服务器验证资源的Last-Modefied头域是否有更新，源服务器可能返回304（Not Modified），则表明该对象仍有效；也可能返回200（OK）替换请求的Cache对象。

此外，HTTP/1.0中还定义了Pragma:no-cache头域，客户端使用该头域说明请求资源不能从cache中获取，而必须回源获取。

HTTP/1.1在1.0的基础上加入了一些cache的新特性，当缓存对象的Age超过Expire时变为stale对象，cache不需要直接抛弃stale对象，而是与源服务器进行重新激活（revalidation）。

HTTP/1.0中，If-Modified-Since头域使用的是绝对时间戳，精确到秒，但使用绝对时间会带来不同机器上的时钟同步问题。而HTTP/1.1中引入了一个ETag头域用于重激活机制，它的值entity tag可以用来唯一的描述一个资源。请求消息中可以使用If-None-Match头域来匹配资源的entitytag是否有变化。

为了使caching机制更加灵活，HTTP/1.1增加了Cache-Control头域（请求消息和响应消息都可使用），它支持一个可扩展的指令子集：例如max-age指令支持相对时间戳；private和no-store指令禁止对象被缓存；no-transform阻止Proxy进行任何改变响应的行为。

Cache使用关键字索引在磁盘中缓存的对象，在HTTP/1.0中使用资源的URL作为关键字。但可能存在不同的资源基于同一个URL的情况，要区别它们还需要客户端提供更多的信息，如Accept-Language和Accept-Charset头域。为了支持这种内容协商机制(content negotiation mechanism)，HTTP/1.1在响应消息中引入了Vary头域，该头域列出了请求消息中需要包含哪些头域用于内容协商。

强缓存、协商缓存
我们在使用浏览器访问一个web页面的时候，浏览器会将该网页中的资源和相应的服务端response header强制缓存起来，在这些头信息中有两个字段来控制强缓存Cache-Control和Expires，如果这两个字段验证通过就使用缓存，如果没有通过就会带着另外两个字段Etag/If-None-Match和Last-Modified/If-Modified-Since去向服务端发送一个验证（协商）请求，如果验证通过就返回304继续使用缓存，如果没有通过就返回200和对应的资源。

- 连接代宽优化
HTTP1.1支持传送内容的一部分。比方说，当客户端已经有内容的一部分，为了节省带宽，可以只向服务器请求一部分。

HTTP/1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了。例如，客户端只需要显示一个文档的部分内容，又比如下载大文件时需要支持断点续传功能，而不是在发生断连后不得不重新下载完整的包。

HTTP/1.1中在请求消息中引入了range头域，它允许只请求资源的某个部分。

"Content-Type": "application/octet-stream",
          "Content-Range": \`bytes ${startPosition}-${endPosition}/${file.size}\`
在响应消息中Content-Range头域声明了返回的这部分对象的起始位置和长度。如果服务器相应地返回了对象所请求范围的内容，则响应码为206（Partial Content），它可以防止Cache将响应误以为是完整的一个对象。我的文件并发上传项目有使用到这个请求方式。

节省带宽资源的一个非常有效的做法就是压缩要传送的数据。Content-Encoding是对消息进行端到端（end-to-end）的编码，它可能是资源在服务器上保存的固有格式（如jpeg图片格式）；在请求消息中加入Accept-Encoding头域，它可以告诉服务器客户端能够解码的编码方式。

而Transfer-Encoding是逐段式（hop-by-hop）的编码，如Chunked编码。在请求消息中加入TE头域用来告诉服务器能够接收的transfer-coding方式，

- 请求Host域
**Host**请求头指明了请求将要发送到的服务器主机名和端口号。HTTP1.0并没有包含Host，

如果没有包含端口号，会自动使用被请求服务的默认端口（比如HTTPS URL使用443端口，HTTP URL使用80端口）。

如果使用的HTTP1.0我们就不能给一个服务器部署多个服务，HTTP1.1解决了这个问题。

所有HTTP/1.1 请求报文中必须包含一个Host头字段。对于缺少Host头或者含有超过一个Host头的HTTP/1.1 请求，可能会收到400（Bad Request）状态码。

请求状态码
HTTP1.1新增了两个1.0中没有的状态码，

100 (Continue) 状态代码的使用，允许客户端在发request消息body之前先用request header试探一下server，看server要不要接收request body，再决定要不要发request body。

101 (Switching Protocols) 当我们在网页中使用websocket的时候就会出现一个这样的状态码

请求方法
HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。

HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。

## HTTP2.0对于HTTP1.x主要有以下改进
http2.0是一种安全高效的下一代http传输协议。安全是因为http2.0建立在https协议的基础上，高效是因为它是通过二进制分帧来进行数据传输。

- 二进制分帧（Binary Format）
有别于HTTP/1.1在连接中的明文请求，HTTP/2与SPDY一样，将一个TCP连接分为若干个流（Stream），每个流中可以传输若干消息（Message），每个消息由若干最小的二进制帧（Frame）组成。这也是HTTP/1.1与HTTP/2最大的区别所在。 HTTP/2中，每个用户的操作行为被分配了一个流编号(stream ID)，这意味着用户与服务端之间创建了一个TCP通道

启用http2.0后会给性能带来很大的提升，但同时也会带来新的性能瓶颈。**因为现在所有的压力集中在底层一个TCP连接之上，TCP很可能就是下一个性能瓶颈，比如TCP分组的队首阻塞问题，单个TCP packet丢失导致整个连接阻塞，无法逃避，此时所有消息都会受到影响。**

- 多路复用 (Multiplexing) / 连接共享，让多个请求合并在同一 TCP 连接内
同一域名下多个请求公用同一个连接，不限制请求数量，双向数据流，多个请求之前数据是无序的，浏览器最终会根据每一帧的编号进行组装。

- 头部压缩（Header Compression）
在HTTP1中每次传输的header都属文本形式传输，当header中的参数比较多时，对于压缩就显得很有必要了，头部会在连接上始终存在，对于多个请求中重复的字段会自动过滤。

- 服务端推送（Server Push）
服务器会对于客户端必需的资源在双方协商好的前提下会主动推送。

- 请求优先级（Request Priorities）
  
HTTP3
HTTP3是一个基于UDP协议的应用层协议，并且集成了HTTP2的加密传输、多路复用的几个特点

HTTP/1.1 有队头阻塞，因为它需要完整地发送响应，并且不能多路复用它们
HTTP/2 通过引入“帧”（frames）标识每个资源块属于哪个“流”（stream）来解决这个问题
然而，TCP 不知道这些单独的“流”（streams），只是把所有的东西看作一个大流（1 big stream）
如果一个 TCP 包丢失，所有后续的包都需要等待它的重传，即使它们包含来自不同流的无关联数据。TCP 具有传输层队头阻塞。