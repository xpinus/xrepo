# 模块化和包管理

> 模块化：分解和聚合

全局污染

依赖混乱

标准：
  民间： CJS(运行时)  AMD CMD UMD
  官方： ESM（编译时）

实现：
  浏览器 ESM
  node  CJS ESM
  构建工具 vue-cli vite ...

> 包管理
 包  react/jquery/lodash
 框架（会约束代码结构）  vue
 npm（package.json registry cli）

 oauth2 ?

> 语言问题

html codepen haml
css less/sass/postcss/css-in-js 
js  

兼容性
语言缺陷


# JS工具链

兼容性
  API兼容
    polyfill: core-js
  语法兼容: 语法\代码转化
    syntax transformer ( runtime )
    如 async await 通过regenerator进行转换
    如 ...解构
    如 ?可选链运算符
```js
const regenerator = require('regenerator');

const res = regenerator.compile('原始代码', {
  includeRuntime: true
})

console.log(res.code)

```

> babel

原始代码 =》 AST（astexplorer.net） = 【 ...babel插件 】  => 代码

预设（一堆插件）：@babel/preset-env

```js
// babel.config.js

module.exports = {
  presets: [
    '@babel/preset-env', {
      // 要兼容的浏览器信息  browserlist ?
      targets: {
        edge: '17',
        firefox: '60',
        chrome: '67',
        safari: '11.1'
      },
      useBuildIns: 'usage', // 按需导入
      corejs: '3.6.5', // 根据安装的版本来
    }
  ]
}

```

swc(rust): 类似babel

# CSS工具链 

语法缺失（循环、判断、拼接）
功能缺失（各种复杂函数）

新语言（less/sass） ==编译==》css

less实现一下星空的效果

css  => 后处理器（厂商前缀/代码压缩/代码剪枝）

postcss 

# 构建工具和脚手架

> webpack rollup  esbuild

webpack：一切都看作模块

入口文件 ==当作字符串==AST语法树==导入语句==模块查找规则


https://developer.aliyun.com/article/1067018 Monorepo，大型前端项目管理模式实践
https://tech.uupt.com/?p=1185

初始化项目
功能开发
集成 & 测试
发布
线上监控

初始化项目
假如是已有仓库，初始化过程很简单，不外乎git clone/git rebase(or merge)两个命令。
假如是新项目，那么你需要做很多技术选型:

代码组织：polyrepo vs monorepo
决定采用设计技术栈(React or Vue? Node or Java? AntD or ArcoDesign? CSR or SSR?)，要做许多技术决策
搭建工程化环境:构建工具、Lint工作流(ESLint/styleLintlPrettierILint-Staged/huscky)、UT 工具、CI/CD等
资源部署:物理服务器、云服务器、faas、CDN(托管静态资源)等

工欲善其事，必先利其器！这些逻辑，通常会被沉淀为脚手架工具(vue-cli/CRA等)，下次更迅速创建项目
功能开发

工具效率：

IDE效率：设计适当的配置&插件环境，有助于减少手动操作次数，提升团队研发效率
单测效率：按需单测 单测覆盖率
构建效率：按需构建 构建逻辑优化 构建


确保不犯错：

接入Typescript，ESLint、StyleLint、CommitLint、lint-staged、prettier等，解决代码风格和类型安全问题
UT(jest/vitest等)确保代码运行效果
这两类工具都有一定上手成本，但能做到吹毛求疵，确保不会发生小错误，保证长期可维护


安全性：

如何避免混入有问题的npm模块
如何确保产物不出现敏感信息(如github token)



集成&测试
Code Review，重在准入规则：经过谁、多少人的 approve后，可以合入代码
配合CR，通常还可以设置许多自动检测的准入条件(所谓的CI)：

构建命令必须成功
Lint必须通过
单测必须通过；单测覆盖率不能降低，且整体覆盖率必须大于阈值(或增量代码的覆盖率大于阈值)
E2E 测试必须通过
性能 diff 检查
各类代码安全检查

