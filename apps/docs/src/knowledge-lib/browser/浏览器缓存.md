# 浏览器缓存

> 浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下

- 先根据这个资源的一些 `http header` 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；
- 当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些`request header`验证这个资源是否命中协商缓存，称为`http`再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；
- 强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。
- 当协商缓存也没命中时，服务器就会将资源发送回客户端。
- 当 `ctrl+f5` 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；
- 当 `f5`刷新网页时，跳过强缓存，但是会检查协商缓存；

## 强缓存



- `Expires`（该字段是 `http1.0` 时的规范，值为一个绝对时间的 `GMT` 格式的时间字符串，代表缓存资源的过期时间）
- `Cache-Control:max-age`（该字段是 `http1.1`的规范，强缓存利用其 `max-age` 值来判断缓存资源的最大生命周期，它的值单位为秒，如300代表5分钟）

[cache-control参数](https://juejin.cn/post/6844903751493369870)

缓存分为强缓存和协商缓存 强缓存 在浏览器加载资源时，先看看 cache-control 里的 max-age，判断数据有没有过期， 如果没有直接使用该缓存 ，有些用户可能会在没有过期的时候就点了刷新按钮，这个 时候浏览器就回去请求服务端，要想避免这样做，可以在 cache-control 里面加一个 immutable. public 允许客户端和虚拟服务器缓存该资源，cache-control 中的一个属性 private 只允许客户端缓存该资源 no-cache 不允许强缓存，可以协商缓存 no-store 不允许缓存

## 协商缓存

- `Last-Modified`（值为资源最后更新时间，随服务器 response 返回）
- `If-Modified-Since`（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）
- `ETag`（表示资源内容的唯一标识，随服务器`response`返回）
- `If-None-Match`（服务器通过比较请求头部的`If-None-Match`与当前资源的`ETag`是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）

浏览器加载资源时，没有命中强缓存，这时候就去请求服务器，去请求服务器的时候， 会带着两个参数，一个是 If-None-Match，也就是响应头中的 etag 属性，每个文件 对应一个 etag;另一个参数是 If-Modified-Since,也就是响应头中的 Last-Modified 属性，带着这两个参数去检验缓存是否真的过期，如果没有过期，则服务器会给浏览器 返回一个 304 状态码，表示缓存没有过期，可以使用旧缓存。 etag 的作用 有时候编辑了文件，但是没有修改，但是 last-modified 属性的时间就会改变，导致 服务器会重新发送资源，但是 etag 的出现就完美的避免了这个问题，他是文件的唯一 标识缓存位置： 内存缓存 Memory-Cache 离线缓存 Service-Worker 磁盘缓存 Disk-Cache 推送缓存 Push-Cache