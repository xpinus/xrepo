# Vue3深入本质

## 虚拟DOM

> DOM工作原理
- 浏览器引擎是如何处理DOM操作的？

WebIDL(web interface definition language)。定义浏览器和js之间如何通信，通过webIDL浏览器开发者可以描述哪些方法可以被js访问，以及这些方法如何被映射到js中。

真实DOM: 浏览器底层调用C++应用API的操作

- 虚拟DOM本质
> 是一种编程概念，在这个概念里，UI是以一种理想化的、“虚拟”的形式保存在内存中

> 虚拟DOM的本质就是普通的JS对象

在Vue中可以通过`h`函数创建虚拟DOM节点

> 为什么需要使用虚拟DOM

使用虚拟dom涉及两个层面的计算
- 创建js对象
- 根据js对象创建DOM节点

平时所说的虚拟DOM快的前提：
- 和谁比较：
  - 肯定是比原生js的DOM操作慢
  - 相比innerHTML比较，在初始化渲染时两者间差距并不大，主要是更新时，虚拟DOM性能更高
  
**虚拟DOM主要是防止在重新渲染时性能恶化**

还有哪些好处？
- 跨平台性：虚拟DOM增加一层抽象层，相当于和底层操作解耦。这个其实是设计原则里的依赖倒置原则：
  - 高层模块不应该依赖底层模块的额实现，两者都应该依赖于抽象。
- 框架更加灵活

## 模板的本质

> 渲染函数（h）

> 模板编译
> 将模板中的字符串编译成渲染函数
- 解析器：将模板字符串解析成对应的模板AST
- 转换器：将模板AST转换为JS AST
- 生成器：将JS AST生成最终的渲染函数

> 编译的时机
- 运行时编译
  - CDN引入Vue时
- 预编译

## 组件树和虚拟DOM树

> 组件树：由组件所组成的树结构
> 虚拟DOM树：指某一个组件内部的虚拟DOM树，**并非整个应用的虚拟DOM结构**

回顾Vue1 Vue2的响应式
- Object.defineProperty
- Dep： 相当于发布者
- Watcher: 相当于观察者
  - Vue1一个响应式数据对应一个Watcher
  - Vue2一个组件对应一个Watcher, 颗粒度放大

## 响应式

### 数据拦截的本质
- js中的数据拦截
  - Vue1\2 Object.defineProperty
  - Vue3 Proxy和Obeject.defineProperty

共同点：
- 都可以实现数据拦截
- 都可以实现深度拦截，Object.defineProperty需要手写递归

不同点：
- 拦截的广度
  - Object.defineProperty针对特定属性进行`读写`拦截，后续新增属性无法拦截
  - Proxy`针对一整个对象的多种操作`，包括属性的读取、复制、属性的删除等拦截
- 性能上的区别
  - 大多数情况下Proxy更加高效

### 响应式数据的本质
> 响应式数据就是被拦截的对象

ref: Object.defineProperty 和 Proxy
reactive: Proxy

> 学会判断某个操作是否会产生拦截, 因为只有拦截才会由依赖收集和派发更新

```js
const state = ref(1)

state;  // 不会产生拦截
console.log(state); // 不会拦截
console.log(state.value) // 会拦截
console.log(state.a) // 不会拦截
state.a = 2 // 不会拦截
delete state.a // 不会拦截
state = 3; // 不会拦截
```

```js
const state = ref({ a: 1})

state;  // 不会产生拦截
console.log(state); // 不会拦截
console.log(state.value) // 会拦截
console.log(state.a) // 不会拦截
console.log(state.value.a) // 不会拦截  出发两层拦截  value  a
state.a = 2 // 不会拦截
delete state.value.a // 会拦截  value的get  a的delete
state = 3; // 不会拦截
```

```js
const state = reactive({ a: 1})

state;  // 不会产生拦截
console.log(state); // 不会拦截
console.log(state.a) // 会拦截
state.a = 2 // 会拦截
state.a = {
  b: {
    c: 3
  }
}  // 会拦截 a的set
console.log(state.a.b.c) // 会拦截 3次
delete state.a // 会拦截  a的delete
```

```js
const arr = reactive([1,2,3])
arr; // 不会
arr.length // 会
arr[0] // 会， 0 的get操作
arr[0] = 4 // 会， 0 的set操作
arr[0].push(4); // 会， 
```